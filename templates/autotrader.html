{% extends "base.html" %}

{% block title %}HELIOS - Autotrader Live{% endblock %}

{% block head_extra %}
<style>
    .autotrader-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 14px;
        margin-bottom: 14px;
    }
    .autotrader-title {
        font-family: 'Space Grotesk', sans-serif;
        font-size: 30px;
        font-weight: 700;
        margin-bottom: 4px;
    }
    .autotrader-subtitle {
        color: var(--text-secondary);
        font-size: 13px;
    }
    .state-pill {
        border: 1px solid rgba(255,255,255,0.14);
        border-radius: 999px;
        padding: 8px 12px;
        font-size: 12px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.4px;
    }
    .state-pill.ok { color: #10B981; border-color: rgba(16,185,129,0.45); background: rgba(16,185,129,0.16); }
    .state-pill.warn { color: #F4D03F; border-color: rgba(244,208,63,0.45); background: rgba(244,208,63,0.15); }
    .state-pill.error { color: #EF4444; border-color: rgba(239,68,68,0.45); background: rgba(239,68,68,0.16); }

    .control-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        row-gap: 10px;
        background: var(--bg-secondary);
        border: 1px solid rgba(255,255,255,0.06);
        border-radius: 12px;
        padding: 10px;
        margin-bottom: 14px;
    }
    .control-btn {
        border: 1px solid rgba(255,255,255,0.16);
        background: rgba(255,255,255,0.05);
        color: var(--text-main);
        border-radius: 8px;
        padding: 7px 11px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.15s ease;
    }
    .control-btn:hover { background: rgba(255,255,255,0.1); }
    .control-btn:disabled {
        cursor: not-allowed;
        opacity: 0.45;
    }
    .control-btn.active {
        border-color: rgba(0,120,255,0.55);
        background: rgba(0,120,255,0.24);
        color: #b8daff;
        box-shadow: inset 0 0 0 1px rgba(0,120,255,0.35);
    }
    .control-link {
        text-decoration: none;
        display: inline-flex;
        align-items: center;
        justify-content: center;
    }
    .btn-start { border-color: rgba(0,120,255,0.5) !important; background: rgba(0,120,255,0.2) !important; }
    .btn-riskoff { border-color: rgba(239,68,68,0.5) !important; background: rgba(239,68,68,0.16) !important; }

    .market-select-wrap {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-left: 8px;
    }
    .market-select-label {
        color: var(--text-muted);
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.35px;
    }
    .market-select {
        background: #1a1f2e;
        border: 1px solid rgba(255,255,255,0.16);
        border-radius: 8px;
        color: var(--text-main);
        padding: 7px 26px 7px 9px;
        font-size: 12px;
        font-family: 'JetBrains Mono', monospace;
        cursor: pointer;
        appearance: none;
        -webkit-appearance: none;
        background-image: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 24 24' fill='none' stroke='%2394a3b8' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E\");
        background-repeat: no-repeat;
        background-position: right 8px center;
    }
    .market-select:focus {
        outline: none;
        border-color: rgba(0,120,255,0.55);
    }
    .market-day-meta {
        color: var(--text-secondary);
        font-size: 10px;
        white-space: normal;
        line-height: 1.45;
    }
    .control-msg {
        flex: 1 1 100%;
        margin-left: 0;
        font-size: 12px;
        color: var(--text-secondary);
        border-top: 1px solid rgba(255,255,255,0.06);
        padding-top: 7px;
    }

    .kpi-grid {
        display: grid;
        /* Auto-wrap based on available width (works even with sidebar). */
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 10px;
        margin-bottom: 14px;
    }
    .kpi {
        background: var(--bg-secondary);
        border: 1px solid rgba(255,255,255,0.06);
        border-radius: 12px;
        padding: 12px;
    }
    .kpi .label {
        font-size: 11px;
        text-transform: uppercase;
        color: var(--text-muted);
        margin-bottom: 8px;
        letter-spacing: 0.4px;
    }
    .kpi .value {
        font-family: 'JetBrains Mono', monospace;
        font-size: 24px;
        font-weight: 700;
    }
    .kpi .value.value-ts {
        font-family: 'Inter', sans-serif;
        font-size: 12px;
        font-weight: 600;
        line-height: 1.4;
    }
    .kpi .sub {
        margin-top: 5px;
        color: var(--text-secondary);
        font-size: 11px;
    }
    .pos { color: #10B981; }
    .neg { color: #EF4444; }

    .layout {
        /* Flex-wrap adapts to the real available width (not just viewport breakpoints). */
        display: flex;
        flex-wrap: wrap;
        align-items: flex-start;
        gap: 12px;
    }
    /* Prevent long content from forcing horizontal overflow in flex/grid contexts. */
    .layout > div {
        min-width: 0;
    }
    .layout > div:first-child {
        flex: 1.45 1 640px;
    }
    .layout > div:last-child {
        flex: 1 1 420px;
    }
    .panel {
        background: var(--bg-secondary);
        border: 1px solid rgba(255,255,255,0.06);
        border-radius: 12px;
        padding: 12px;
        margin-bottom: 12px;
        min-width: 0;
    }
    .panel-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 10px;
        margin-bottom: 9px;
        padding-bottom: 8px;
        border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    .panel-title {
        font-size: 12px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.4px;
    }
    .panel-meta {
        font-size: 11px;
        color: var(--text-secondary);
        min-width: 0;
        overflow-wrap: anywhere;
    }
    .table-wrap {
        max-height: 460px;
        overflow: auto;
        max-width: 100%;
    }
    .table {
        width: 100%;
        border-collapse: collapse;
    }
    .table th {
        text-align: left;
        font-size: 11px;
        color: var(--text-muted);
        padding: 7px 4px;
        border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .table td {
        padding: 8px 4px;
        border-bottom: 1px solid rgba(255,255,255,0.05);
        font-size: 12px;
        vertical-align: top;
    }
    .signal-table th:first-child,
    .signal-table td:first-child {
        width: 180px;
        min-width: 180px;
    }
    .signal-table {
        /* Keep the timeline table readable on narrow panels; allow the Risk cell to wrap. */
        table-layout: fixed;
    }
    .signal-table th:nth-child(2),
    .signal-table td:nth-child(2) {
        width: 160px;
    }
    .signal-table th:nth-child(3),
    .signal-table td:nth-child(3) {
        width: 110px;
    }
    .signal-table th:nth-child(5),
    .signal-table td:nth-child(5) {
        width: 90px;
    }
    .signal-table th:nth-child(6),
    .signal-table td:nth-child(6) {
        width: 70px;
    }
    .signal-table td:nth-child(4) {
        white-space: normal;
        overflow-wrap: anywhere;
    }
    .mono { font-family: 'JetBrains Mono', monospace; }
    .cost-highlight { color: #fbbf24; font-weight: 600; }
    .actions { display: flex; flex-direction: column; gap: 3px; }
    .action {
        display: inline-flex;
        align-items: center;
        gap: 7px;
        font-size: 11px;
        flex-wrap: wrap;
    }
    .side {
        min-width: 78px;
        text-align: center;
        border-radius: 999px;
        padding: 2px 7px;
        font-size: 10px;
        font-weight: 700;
        text-transform: uppercase;
    }
    .side-note {
        font-size: 10px;
        opacity: 0.88;
    }
    .side.buy { color: #10B981; border: 1px solid rgba(16,185,129,0.45); background: rgba(16,185,129,0.16); }
    .side.sell { color: #EF4444; border: 1px solid rgba(239,68,68,0.45); background: rgba(239,68,68,0.16); }
    .badge {
        display: inline-flex;
        border-radius: 999px;
        padding: 2px 8px;
        font-size: 10px;
        font-weight: 700;
        text-transform: uppercase;
    }
    .badge.ok { color: #10B981; background: rgba(16,185,129,0.16); border: 1px solid rgba(16,185,129,0.45); }
    .badge.warn { color: #F4D03F; background: rgba(244,208,63,0.15); border: 1px solid rgba(244,208,63,0.45); }
    .badge.error { color: #EF4444; background: rgba(239,68,68,0.16); border: 1px solid rgba(239,68,68,0.45); }
    .muted { color: var(--text-secondary); font-size: 11px; }
    .empty { color: var(--text-muted); font-style: italic; font-size: 12px; padding: 7px 0; }

    .metric-grid {
        display: grid;
        /* Collapses to 1 column when the panel is narrow (no viewport dependency). */
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 8px;
    }
    .metric {
        border: 1px solid rgba(255,255,255,0.07);
        border-radius: 8px;
        padding: 8px;
        background: rgba(255,255,255,0.03);
        min-width: 0;
    }
    .metric .label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; margin-bottom: 4px; letter-spacing: 0.3px; }
    .metric .value { font-family: 'JetBrains Mono', monospace; font-size: 14px; overflow-wrap: anywhere; }

    .execution-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
        gap: 10px;
    }
    .mini-list {
        max-height: 430px;
        min-height: 360px;
        overflow: auto;
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding-right: 4px;
    }
    .mini-list::-webkit-scrollbar { width: 10px; }
    .mini-list::-webkit-scrollbar-thumb { background: rgba(148,163,184,0.45); border-radius: 99px; }
    .mini-list::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 99px; }
    .mini-item {
        border: 1px solid rgba(255,255,255,0.09);
        border-radius: 10px;
        padding: 9px 10px;
        background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.015));
    }
    .mini-item .head { display: flex; justify-content: space-between; align-items: flex-start; gap: 8px; font-size: 11px; color: var(--text-secondary); margin-bottom: 5px; }
    .mini-item .head > span { min-width: 0; }
    .mini-item .head > span:last-child { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .mini-item .line { font-size: 13px; font-weight: 600; }
    .tz-stack {
        display: flex;
        flex-direction: column;
        gap: 2px;
        line-height: 1.35;
        white-space: nowrap;
    }
    .tz-stack .tz-line {
        font-family: 'JetBrains Mono', monospace;
        font-size: 11px;
        color: var(--text-secondary);
    }
    .tz-stack .tz-line strong {
        color: var(--text-main);
        font-weight: 700;
    }

    .bar-wrap {
        height: 8px;
        background: rgba(255,255,255,0.08);
        border-radius: 999px;
        overflow: hidden;
        margin-top: 5px;
    }
    .bar {
        height: 100%;
        background: linear-gradient(90deg, #0078FF, #00D4FF);
    }
    .intraday-wrap {
        height: 380px;
        min-height: 280px;
        position: relative;
    }
    .intraday-meta {
        font-size: 11px;
        color: var(--text-secondary);
        margin-bottom: 8px;
    }

    .market-table-wrap {
        overflow: auto;
    }
    .market-table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0 6px;
        table-layout: fixed;
    }
    .market-table th {
        text-align: left;
        color: var(--text-muted);
        text-transform: uppercase;
        font-size: 10px;
        letter-spacing: 0.3px;
        padding: 0 12px 3px 12px;
    }
    .market-table td {
        font-size: 12px;
        padding: 10px 12px;
        background: rgba(255,255,255,0.02);
        border-top: 1px solid rgba(255,255,255,0.06);
        border-bottom: 1px solid rgba(255,255,255,0.06);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
    .market-table td:first-child {
        border-left: 1px solid rgba(255,255,255,0.06);
        border-radius: 10px 0 0 10px;
    }
    .market-table td:last-child {
        border-right: 1px solid rgba(255,255,255,0.06);
        border-radius: 0 10px 10px 0;
    }
    .market-table col.bracket { width: 30%; }
    .market-table col.yes-col { width: 10%; }
    .market-table col.no-col { width: 10%; }
    .market-table col.ob-yes-col { width: 18%; }
    .market-table col.ob-no-col { width: 18%; }
    .market-table col.spread-col { width: 14%; }
    .market-name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .yes { color: #10B981; font-family: 'JetBrains Mono', monospace; }
    .no { color: #EF4444; font-family: 'JetBrains Mono', monospace; }
    .spread { color: #F4D03F; font-family: 'JetBrains Mono', monospace; }
    .market-source {
        display: block;
        margin-top: 2px;
        color: var(--text-muted);
        font-size: 10px;
        font-family: 'JetBrains Mono', monospace;
    }

    .edge-table col.bracket { width: 28%; }
    .edge-table col.model-col { width: 12%; }
    .edge-table col.market-col { width: 12%; }
    .edge-table col.ob-col { width: 18%; }
    .edge-table col.edge-col { width: 10%; }
    .edge-table col.action-col { width: 12%; }
    .edge-table col.ev-col { width: 8%; }
    .edge-action { font-weight: 800; font-size: 11px; text-transform: uppercase; }
    .edge-action.buy { color: #10B981; }
    .edge-action.sell { color: #EF4444; }
    .edge-action.hold { color: var(--text-secondary); font-weight: 700; }

    @media (max-width: 760px) {
        /* Force single-column on very small viewports for readability. */
        .kpi-grid { grid-template-columns: 1fr; }
        .metric-grid { grid-template-columns: 1fr; }
        .control-msg { width: 100%; margin-left: 0; }
        .market-select-wrap {
            width: 100%;
            margin-left: 0;
            flex-wrap: wrap;
        }
        .market-day-meta {
            white-space: normal;
        }
        .execution-grid {
            grid-template-columns: 1fr;
        }
        .mini-list {
            min-height: 250px;
        }
    }

    .strategy-row {
        display: flex;
        justify-content: space-between;
        gap: 10px;
        font-size: 12px;
    }
    .strategy-name {
        min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
</style>
{% endblock %}

{% block content %}
<div class="page-content">
<div class="autotrader-header">
    <div>
        <div class="autotrader-title">Autotrader Live Signals</div>
        <div class="autotrader-subtitle">Realtime signals with Helios nowcast, Polymarket prices/orderbook and risk management.</div>
        <div class="autotrader-subtitle">Legend: <strong>qty</strong> = shares/contracts. <strong>edge</strong> = strategy advantage vs market mid.</div>
    </div>
    <div id="state-pill" class="state-pill warn">Initializing</div>
</div>

<div class="control-row">
    <button id="btn-start" class="control-btn btn-start" onclick="sendControl('start')">Start</button>
    <button id="btn-pause" class="control-btn" onclick="sendControl('pause')">Pause</button>
    <button id="btn-resume" class="control-btn" onclick="sendControl('resume')">Resume</button>
    <button id="btn-riskoff" class="control-btn btn-riskoff" onclick="sendControl('risk_off')">Risk Off</button>
    <button id="btn-riskon" class="control-btn" onclick="sendControl('risk_on')">Risk On</button>
    <button id="btn-refresh" class="control-btn" onclick="manualRefresh()">Refresh</button>
    <a href="/autotrader/tutorial" class="control-btn control-link">Tutorial</a>

    <div class="market-select-wrap">
        <span class="market-select-label">Market</span>
        <select id="market-day-select" class="market-select" onchange="onMarketDayChange()">
            <option value="0">Today</option>
            <option value="1">Tomorrow</option>
        </select>
        <span id="market-day-meta" class="market-day-meta">day: --</span>
    </div>

    <span id="control-msg" class="control-msg">Waiting for data...</span>
</div>

<div class="kpi-grid">
    <div class="kpi">
        <div class="label">Total PnL</div>
        <div id="kpi-pnl" class="value mono">--</div>
        <div id="kpi-pnl-sub" class="sub">realized + mtm</div>
    </div>
    <div class="kpi">
        <div class="label">Max Drawdown</div>
        <div id="kpi-dd" class="value mono">--</div>
        <div class="sub">risk-first limit tracking</div>
    </div>
    <div class="kpi">
        <div class="label">Orders / Fills</div>
        <div id="kpi-of" class="value mono">--</div>
        <div id="kpi-costs" class="sub">fees/slippage: --</div>
    </div>
    <div class="kpi">
        <div class="label">Last Decision</div>
        <div id="kpi-last" class="value mono">--</div>
        <div id="kpi-strategy" class="sub">strategy: --</div>
    </div>
</div>

<div class="panel">
    <div class="panel-header">
        <div class="panel-title">Intraday Signals Chart</div>
        <div id="intraday-meta" class="panel-meta">loading...</div>
    </div>
    <div id="intraday-submeta" class="intraday-meta">tmax mean +/- sigma with signals and fills</div>
    <div class="intraday-wrap">
        <canvas id="intraday-chart"></canvas>
    </div>
</div>

<div class="layout">
    <div>
        <div class="panel">
            <div class="panel-header">
                <div class="panel-title">Signal Timeline</div>
                <div id="signals-meta" class="panel-meta">latest decisions</div>
            </div>
            <div class="table-wrap">
                <table class="table signal-table">
                    <thead>
                        <tr>
                            <th>Time</th>
                            <th>Strategy</th>
                            <th>Signal</th>
                            <th>Risk</th>
                            <th>Reward</th>
                            <th>Fills</th>
                        </tr>
                    </thead>
                    <tbody id="signals-body">
                        <tr><td colspan="6" class="empty">No decisions yet.</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="panel">
            <div class="panel-header">
                <div class="panel-title">Execution Tape</div>
                <div class="panel-meta">latest paper fills/orders</div>
            </div>
            <div class="execution-grid">
                <div>
                    <div class="panel-meta" style="margin-bottom:6px;">Fills</div>
                    <div id="fills-box" class="mini-list"><div class="empty">No fills yet.</div></div>
                </div>
                <div>
                    <div class="panel-meta" style="margin-bottom:6px;">Orders</div>
                    <div id="orders-box" class="mini-list"><div class="empty">No orders yet.</div></div>
                </div>
            </div>
        </div>

    </div>

    <div>
        <div class="panel">
            <div class="panel-header">
                <div class="panel-title">Runtime Status</div>
                <div id="status-meta" class="panel-meta">station: --</div>
            </div>
            <div id="status-badges" style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:9px;"></div>
            <div class="metric-grid">
                <div class="metric"><div class="label">Mode</div><div id="st-mode" class="value">--</div></div>
                <div class="metric"><div class="label">Selection</div><div id="st-selection" class="value">--</div></div>
                <div class="metric"><div class="label">Interval</div><div id="st-interval" class="value">--</div></div>
                <div class="metric"><div class="label">Market Buckets</div><div id="st-buckets" class="value">--</div></div>
            </div>
        </div>

        <div class="panel">
            <div class="panel-header">
                <div class="panel-title">Decision Context</div>
                <div id="ctx-meta" class="panel-meta">--</div>
            </div>
            <div class="metric-grid">
                <div class="metric"><div class="label">Confidence</div><div id="ctx-confidence" class="value">--</div></div>
                <div class="metric"><div class="label">Sigma F</div><div id="ctx-sigma" class="value">--</div></div>
                <div class="metric"><div class="label">Nowcast Age</div><div id="ctx-n-age" class="value">--</div></div>
                <div class="metric"><div class="label">Market Age</div><div id="ctx-m-age" class="value">--</div></div>
                <div class="metric"><div class="label">Spread Top</div><div id="ctx-spread" class="value">--</div></div>
                <div class="metric"><div class="label">Depth Imbalance</div><div id="ctx-imbalance" class="value">--</div></div>
                <div class="metric"><div class="label">Volatility</div><div id="ctx-vol" class="value">--</div></div>
                <div class="metric"><div class="label">QC</div><div id="ctx-qc" class="value">--</div></div>
            </div>
        </div>

        <div class="panel">
            <div class="panel-header"><div class="panel-title">Strategies</div><div class="panel-meta">selection share + reward</div></div>
            <div id="strategies-box"><div class="empty">No strategy stats.</div></div>
        </div>

        <div class="panel">
            <div class="panel-header"><div class="panel-title">Open Positions</div><div class="panel-meta">paper inventory</div></div>
            <div id="positions-box"><div class="empty">No open positions.</div></div>
        </div>

        <div class="panel">
            <div class="panel-header"><div class="panel-title">Helios Top Buckets</div><div id="nowcast-meta" class="panel-meta">loading...</div></div>
            <div id="nowcast-box"><div class="empty">No nowcast data.</div></div>
        </div>

        <div class="panel">
            <div class="panel-header"><div class="panel-title">Fair vs Market (Edge)</div><div id="edge-meta" class="panel-meta">loading...</div></div>
            <div id="edge-box"><div class="empty">No edge table.</div></div>
        </div>

        <div class="panel">
            <div class="panel-header"><div class="panel-title">Polymarket Live Prices</div><div id="market-meta" class="panel-meta">loading...</div></div>
            <div id="market-box"><div class="empty">No market data.</div></div>
        </div>
    </div>
</div>
</div>
{% endblock %}

{% block scripts %}
<script>
const STATION_TIMEZONES = {
{% for sid, stn in all_stations.items() %}
    "{{ sid }}": "{{ stn.timezone }}",
{% endfor %}
};

const AUTOTRADER_INITIAL_STATION = (window.HeliosStationState && window.HeliosStationState.get())
    ? window.HeliosStationState.get()
    : "{{ active_stations[0] if active_stations else 'KLGA' }}";

const live = {
    stationId: AUTOTRADER_INITIAL_STATION,
    stationTz: STATION_TIMEZONES[AUTOTRADER_INITIAL_STATION] || "{{ all_stations[active_stations[0]].timezone if active_stations else 'America/New_York' }}",
    targetDay: 0,
    fastTimer: null,
    slowTimer: null,
    pendingAction: null,
    lastStatus: null,
    intradayChart: null,
};

function esc(v) {
    if (v === null || v === undefined) return "";
    return String(v).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll("\"","&quot;").replaceAll("'","&#39;");
}
function num(v, d = 4) {
    if (v === null || v === undefined || Number.isNaN(Number(v))) return "--";
    return Number(v).toFixed(d);
}
function pct(v, d = 1) {
    if (v === null || v === undefined || Number.isNaN(Number(v))) return "--";
    return `${(Number(v) * 100).toFixed(d)}%`;
}
function signed(v, d = 4) {
    if (v === null || v === undefined || Number.isNaN(Number(v))) return "--";
    const n = Number(v);
    return `${n > 0 ? "+" : ""}${n.toFixed(d)}`;
}
function formatActionReason(reason) {
    const txt = String(reason || "");
    const m = txt.match(/Edge=([+-]?[0-9]*\\.?[0-9]+),\\s*Model=([+-]?[0-9]*\\.?[0-9]+),\\s*Market=([+-]?[0-9]*\\.?[0-9]+)/i);
    if (!m) return txt;
    const edge = Number(m[1]);
    const model = Number(m[2]);
    const market = Number(m[3]);
    return `edge ${signed(edge, 3)} | model ${(model * 100).toFixed(1)}c | market ${(market * 100).toFixed(1)}c`;
}
function calcCost(action) {
    const qty = Number(action.target_size ?? action.size ?? 0);
    if (!qty) return null;
    // max_price is the per-share limit price for the specific token (YES or NO)
    const price = Number(action.max_price);
    if (!price || price <= 0 || Number.isNaN(price)) return null;
    return qty * price;
}
function ago(v) {
    if (!v) return "--";
    const d = new Date(v);
    if (Number.isNaN(d.getTime())) return "--";
    const s = Math.max(0, Math.floor((Date.now() - d.getTime()) / 1000));
    if (s < 60) return `${s}s ago`;
    const m = Math.floor(s / 60);
    if (m < 60) return `${m}m ago`;
    return `${Math.floor(m / 60)}h ago`;
}
async function j(url) {
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
    return r.json();
}

function stationTimezone(stationId) {
    return STATION_TIMEZONES[stationId] || "America/New_York";
}

function fmtDateInTz(dateObj, tz) {
    return new Intl.DateTimeFormat("en-CA", {
        timeZone: tz,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
    }).format(dateObj);
}

function formatDateTimeInTz(value, tz) {
    if (!value) return "--";
    const date = value instanceof Date ? value : new Date(value);
    if (Number.isNaN(date.getTime())) return "--";
    const parts = new Intl.DateTimeFormat("en-CA", {
        timeZone: tz,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        hour12: false,
    }).formatToParts(date);
    const get = (type) => parts.find((p) => p.type === type)?.value || "--";
    return `${get("year")}-${get("month")}-${get("day")} ${get("hour")}:${get("minute")}:${get("second")}`;
}

const AT_TZ_LABELS = {
    'KLGA': 'NYC',
    'KATL': 'ATL',
    'KORD': 'CHI',
    'KMIA': 'MIA',
    'KDAL': 'DAL',
    'LFPG': 'PAR',
    'EGLC': 'LON',
    'LTAC': 'ANK'
};

function dualTsHtml(value) {
    const localTz = live.stationTz || "America/New_York";
    const label = AT_TZ_LABELS[live.stationId] || live.stationId || 'Local';
    const local = formatDateTimeInTz(value, localTz);
    const es = formatDateTimeInTz(value, "Europe/Madrid");
    return `<div class="tz-stack"><span class="tz-line"><strong>${label}</strong> ${local}</span><span class="tz-line"><strong>ES</strong> ${es}</span></div>`;
}

function setControlMessage(text, level = "info") {
    const msg = document.getElementById("control-msg");
    msg.textContent = text;
    if (level === "error") msg.style.color = "#EF4444";
    else if (level === "warn") msg.style.color = "#F4D03F";
    else msg.style.color = "var(--text-secondary)";
}

function sideIntent(side, outcome = "yes") {
    const s = String(side || "buy").toLowerCase();
    const o = String(outcome || "yes").toLowerCase();
    if (o === "no") {
        if (s === "buy") return { css: "buy", primary: "BUY NO", equiv: "" };
        return { css: "sell", primary: "SELL NO", equiv: "" };
    }
    if (s === "buy") return { css: "buy", primary: "BUY YES", equiv: "" };
    return { css: "sell", primary: "SELL YES", equiv: "" };
}

function firstNum(...values) {
    for (const v of values) {
        if (v === null || v === undefined) continue;
        const n = Number(v);
        if (!Number.isNaN(n)) return n;
    }
    return null;
}

function fmtBookPair(bid, ask) {
    if (bid === null || bid === undefined || ask === null || ask === undefined) return "--";
    return `${(Number(bid) * 100).toFixed(1)}c / ${(Number(ask) * 100).toFixed(1)}c`;
}

function toMillis(ts) {
    if (!ts) return null;
    const n = Date.parse(ts);
    return Number.isNaN(n) ? null : n;
}

function setControlsDisabled(disabled) {
    ["btn-start", "btn-pause", "btn-resume", "btn-riskoff", "btn-riskon", "btn-refresh"].forEach((id) => {
        const el = document.getElementById(id);
        if (el) el.disabled = !!disabled;
    });
}

function setControlActive(status) {
    const isRunning = !!status?.running;
    const isPaused = !!status?.paused;
    const isRiskOff = !!status?.risk_off;

    const btnStart = document.getElementById("btn-start");
    const btnPause = document.getElementById("btn-pause");
    const btnResume = document.getElementById("btn-resume");
    const btnRiskOff = document.getElementById("btn-riskoff");
    const btnRiskOn = document.getElementById("btn-riskon");

    [btnStart, btnPause, btnResume, btnRiskOff, btnRiskOn].forEach((btn) => btn?.classList.remove("active"));

    if (btnStart) {
        btnStart.classList.toggle("active", isRunning && !isPaused);
        btnStart.disabled = isRunning && !isPaused;
    }
    if (btnPause) {
        btnPause.classList.toggle("active", isPaused);
        btnPause.disabled = !isRunning || isPaused;
    }
    if (btnResume) {
        btnResume.classList.toggle("active", isRunning && !isPaused);
        btnResume.disabled = !isRunning || !isPaused;
    }
    if (btnRiskOff) {
        btnRiskOff.classList.toggle("active", isRiskOff);
        btnRiskOff.disabled = isRiskOff;
    }
    if (btnRiskOn) {
        btnRiskOn.classList.toggle("active", !isRiskOff);
        btnRiskOn.disabled = !isRiskOff;
    }
}

function updateMarketDayMeta() {
    const meta = document.getElementById("market-day-meta");
    const now = new Date();
    const target = new Date(now.getTime() + (live.targetDay * 24 * 60 * 60 * 1000));

    const stationDate = fmtDateInTz(target, live.stationTz);
    const localLabel = AT_TZ_LABELS[live.stationId] || live.stationId || 'Local';
    const localNow = formatDateTimeInTz(now, live.stationTz);
    const esNow = formatDateTimeInTz(now, "Europe/Madrid");

    meta.textContent = `D+${live.targetDay} | ${localLabel} date: ${stationDate} | ${localLabel} now: ${localNow} | ES now: ${esNow}`;
}

function setStatePill(status) {
    const el = document.getElementById("state-pill");
    if (!status) { el.className = "state-pill warn"; el.textContent = "No status"; return; }
    if (status.risk_off) { el.className = "state-pill error"; el.textContent = "Risk OFF"; return; }
    if (status.paused) { el.className = "state-pill warn"; el.textContent = "Paused"; return; }
    if (status.running) { el.className = "state-pill ok"; el.textContent = "Running"; return; }
    el.className = "state-pill warn"; el.textContent = "Stopped";
}

function renderStatus(status, decisions, positions, strategies) {
    setStatePill(status);
    live.lastStatus = status || null;
    live.stationId = status?.station_id || live.stationId;
    live.stationTz = stationTimezone(live.stationId);
    const stSel = document.getElementById("station-select");
    if (stSel && stSel.value !== live.stationId) stSel.value = live.stationId;
    setControlActive(status);
    updateMarketDayMeta();

    const perf = status?.performance || {};
    const total = Number(perf.total_pnl || 0);
    const pnlEl = document.getElementById("kpi-pnl");
    pnlEl.textContent = signed(total, 4);
    pnlEl.className = `value mono ${total > 0 ? "pos" : (total < 0 ? "neg" : "")}`;
    document.getElementById("kpi-pnl-sub").textContent = `realized ${signed(perf.realized_pnl || 0, 4)} | mtm ${signed(perf.mark_to_market_pnl || 0, 4)}`;
    document.getElementById("kpi-dd").textContent = num(status?.max_drawdown_abs || 0, 4);
    document.getElementById("kpi-dd").className = "value mono neg";
    const dayPerf = status?.performance_day || {};
    const dayOrders = Number(dayPerf.orders_count ?? perf.total_orders ?? 0);
    const dayFills = Number(dayPerf.fills_count ?? perf.total_fills ?? 0);
    document.getElementById("kpi-of").textContent = `${dayOrders} / ${dayFills}`;
    document.getElementById("kpi-costs").textContent =
        `day ${dayPerf.target_date || "--"} | session ${perf.total_orders || 0}/${perf.total_fills || 0} | fees ${num(perf.total_fees || 0, 4)} | slip ${num(perf.total_slippage || 0, 4)}`;
    const last = decisions && decisions.length ? decisions[decisions.length - 1] : null;
    const lastEl = document.getElementById("kpi-last");
    if (last?.ts_utc) {
        lastEl.className = "value value-ts";
        lastEl.innerHTML = dualTsHtml(last.ts_utc);
        document.getElementById("kpi-strategy").textContent = `strategy: ${last?.selected_strategy || "--"} | ${ago(last.ts_utc)}`;
    } else {
        lastEl.className = "value mono";
        lastEl.textContent = "--";
        document.getElementById("kpi-strategy").textContent = "strategy: --";
    }

    document.getElementById("status-meta").textContent = `station: ${status?.station_id || "--"}`;
    document.getElementById("st-mode").textContent = status?.mode || "--";
    document.getElementById("st-selection").textContent = status?.selection_mode || "--";
    document.getElementById("st-interval").textContent = status?.decision_interval_seconds ? `${status.decision_interval_seconds}s` : "--";
    const marketBuckets = status?.last_context?.market_bucket_count;
    const overlapBuckets = status?.last_context?.market_overlap_count;
    const nowcastBuckets = status?.last_context?.nowcast_bucket_count;
    if (
        marketBuckets !== undefined && marketBuckets !== null &&
        overlapBuckets !== undefined && overlapBuckets !== null &&
        nowcastBuckets !== undefined && nowcastBuckets !== null
    ) {
        document.getElementById("st-buckets").textContent = `${marketBuckets} (match ${overlapBuckets}/${nowcastBuckets})`;
    } else {
        document.getElementById("st-buckets").textContent = String(marketBuckets ?? "--");
    }
    document.getElementById("status-badges").innerHTML = [
        `<span class="badge ${status?.running ? "ok" : "warn"}">engine ${status?.running ? "on" : "off"}</span>`,
        `<span class="badge ${status?.paused ? "warn" : "ok"}">paused ${status?.paused ? "yes" : "no"}</span>`,
        `<span class="badge ${status?.risk_off ? "error" : "ok"}">risk_off ${status?.risk_off ? "yes" : "no"}</span>`
    ].join("");

    const c = status?.last_context || {};
    document.getElementById("ctx-meta").innerHTML = c.ts_utc ? dualTsHtml(c.ts_utc) : "--";
    document.getElementById("ctx-confidence").textContent = pct(c.confidence, 1);
    document.getElementById("ctx-sigma").textContent = num(c.tmax_sigma_f, 2);
    document.getElementById("ctx-n-age").textContent = num(c.nowcast_age_seconds, 0);
    document.getElementById("ctx-m-age").textContent = num(c.market_age_seconds, 0);
    document.getElementById("ctx-spread").textContent = num(c.spread_top, 4);
    document.getElementById("ctx-imbalance").textContent = num(c.depth_imbalance, 3);
    document.getElementById("ctx-vol").textContent = num(c.volatility_short, 4);
    document.getElementById("ctx-qc").textContent = c.qc_state || "--";

    renderStrategies(strategies || []);
    renderPositions(positions || {});
}

function renderSignals(decisions) {
    const body = document.getElementById("signals-body");
    const meta = document.getElementById("signals-meta");
    if (!decisions.length) {
        body.innerHTML = '<tr><td colspan="6" class="empty">No decisions yet.</td></tr>';
        meta.textContent = "latest decisions";
        return;
    }
    const sorted = [...decisions].reverse();
    meta.textContent = `${sorted.length} decisions loaded`;
    body.innerHTML = sorted.map((d) => {
        const acts = Array.isArray(d.actions) ? d.actions : [];
        const signalHtml = acts.length
            ? `<div class="actions">${acts.map((a) => `
                <div class="action">
                    ${(() => {
                        const intent = sideIntent(a.side, a.outcome || "yes");
                        const note = intent.equiv ? `<span class="muted side-note">${intent.equiv}</span>` : "";
                        return `<span class="side ${intent.css}">${intent.primary}</span>${note}`;
                    })()}
                    <span class="mono">${esc(a.bucket || "-")}</span>
                    ${(() => {
                        const cost = calcCost(a);
                        const qty = num(a.target_size ?? a.size, 3);
                        if (cost !== null) {
                            return `<span class="mono cost-highlight">$${cost.toFixed(2)}</span><span class="muted mono">( ${qty} sh )</span>`;
                        }
                        return `<span class="mono">qty ${qty}</span>`;
                    })()}
                    <span class="mono">${esc(a.order_type || "-")}</span>
                    ${a.reason ? `<span class="muted">${esc(formatActionReason(a.reason))}</span>` : ""}
                </div>`).join("")}</div>`
            : `<span class="muted">NO TRADE</span>`;
        const blocked = !!d.risk_blocked;
        const riskReasons = (d.risk_reasons || []).map(esc).join(", ");
        const noTradeReasons = (d.no_trade_reasons || []).map(esc).join(", ");
        let riskHtml = `<span class="badge ok">pass</span>`;
        if (blocked) {
            riskHtml = `<span class="badge error">blocked</span><div class="muted">${riskReasons || "risk_gate"}</div>`;
        } else if (!acts.length) {
            riskHtml = `<span class="badge warn">no_trade</span><div class="muted">${noTradeReasons || "no_signal"}</div>`;
        }
        const reward = d.reward === null || d.reward === undefined ? "--" : signed(d.reward, 4);
        const rewardCls = Number(d.reward || 0) > 0 ? "pos" : (Number(d.reward || 0) < 0 ? "neg" : "");
        return `
            <tr>
                <td>${dualTsHtml(d.ts_utc)}</td>
                <td>${esc(d.selected_strategy || "--")}</td>
                <td>${signalHtml}</td>
                <td>${riskHtml}</td>
                <td class="mono ${rewardCls}">${reward}</td>
                <td class="mono">${Number(d.fills_count || 0)}</td>
            </tr>`;
    }).join("");
}

function renderMini(items, id, type) {
    const box = document.getElementById(id);
    if (!items.length) { box.innerHTML = `<div class="empty">No ${type} yet.</div>`; return; }
    box.innerHTML = items.map((x) => {
        const px = type === "fills" ? num(x.price, 3) : num(x.limit_price, 3);
        const extra = type === "fills"
            ? `fees ${num(x.fees, 4)} | slip ${num(x.slippage, 4)} | ${esc(x.fill_type || "--")}`
            : `${esc(x.order_type || "--")} | ${esc(x.status || "--")}`;
        return `
            <div class="mini-item">
                <div class="head"><span>${dualTsHtml(x.ts_utc)}</span><span>${esc(x.strategy_name || "-")}</span></div>
                <div class="line">
                    ${(() => {
                        const intent = sideIntent(x.side, x.outcome || "yes");
                        const note = intent.equiv ? `<span class="muted side-note">${intent.equiv}</span>` : "";
                        return `<span class="side ${intent.css}">${intent.primary}</span>${note}`;
                    })()}
                    <span class="mono">${esc(x.bucket || "--")}</span>
                    <span class="mono">qty ${num(x.size, 3)} @ ${px}</span>
                </div>
                <div class="muted mono">${extra}</div>
            </div>`;
    }).join("");
}

function renderStrategies(rows) {
    const box = document.getElementById("strategies-box");
    if (!rows.length) { box.innerHTML = '<div class="empty">No strategy stats.</div>'; return; }
    box.innerHTML = rows.map((r) => {
        const w = Math.max(0, Math.min(Number(r.selected_weight || 0) * 100, 100));
        const rew = Number(r.reward_sum || 0);
        return `
            <div style="margin-bottom:9px;">
                <div class="strategy-row">
                    <span class="strategy-name">${esc(r.name || "--")} (${r.selected_count || 0})</span>
                    <span class="mono ${rew > 0 ? "pos" : (rew < 0 ? "neg" : "")}">${signed(rew, 4)}</span>
                </div>
                <div class="bar-wrap"><div class="bar" style="width:${w.toFixed(1)}%"></div></div>
            </div>`;
    }).join("");
}

function renderPositions(positions) {
    const box = document.getElementById("positions-box");
    const rows = Object.entries(positions || {});
    if (!rows.length) { box.innerHTML = '<div class="empty">No open positions.</div>'; return; }
    box.innerHTML = `
        <table class="table">
            <thead><tr><th>Bucket</th><th>Size</th><th>Avg</th><th>Unrealized</th></tr></thead>
            <tbody>
                ${rows.map(([b, p]) => {
                    const u = Number(p.unrealized_pnl || 0);
                    return `<tr>
                        <td class="mono">${esc(b)}</td>
                        <td class="mono">${num(p.size, 3)}</td>
                        <td class="mono">${num(p.avg_price, 3)}</td>
                        <td class="mono ${u > 0 ? "pos" : (u < 0 ? "neg" : "")}">${signed(p.unrealized_pnl, 4)}</td>
                    </tr>`;
                }).join("")}
            </tbody>
        </table>`;
}

function renderNowcast(n, m) {
    const meta = document.getElementById("nowcast-meta");
    const box = document.getElementById("nowcast-box");
    if (!n || n.error) {
        meta.textContent = "no nowcast";
        box.innerHTML = `<div class="empty">${esc(n?.error || "No nowcast data.")}</div>`;
        return;
    }

    const mean = Number(n?.tmax_mean_f);
    const sigma = Number(n?.tmax_sigma_f ?? n?.tmax_sigma ?? 0.0);
    const observedMax = Number(n?.observed_max_f);
    const hasObservedMax = Number.isFinite(observedMax);

    // Prefer a model distribution over the market's tradable labels so this panel
    // matches the Edge table below.
    let view = "raw";
    let shownBucket = null;
    if (
        m
        && !m.error
        && Array.isArray(m.brackets)
        && m.brackets.length
        && Number.isFinite(mean)
        && Number.isFinite(sigma)
    ) {
        const byLabel = {};
        for (const b of (m.brackets || [])) {
            const label = normLabel(b?.name || b?.label || "");
            if (!label) continue;
            byLabel[label] = b;
        }
        const labels = sortLabels(Object.keys(byLabel));
        const probs = [];
        let total = 0.0;
        for (const label of labels) {
            let p = modelProbForLabel(label, mean, sigma);
            if (!Number.isFinite(p) || Number.isNaN(p)) continue;
            if (hasObservedMax && isImpossibleWithObservedMax(label, observedMax)) p = 0.0;
            probs.push({ label, probability: p });
            total += p;
        }
        if (total > 0) {
            for (const row of probs) row.probability = row.probability / total;
        }
        shownBucket = probs.sort((a, b) => Number(b.probability || 0) - Number(a.probability || 0));
        view = "model";
    }
    if (!shownBucket) {
        shownBucket = n?.calibrated?.p_bucket || n?.p_bucket || [];
        view = n?.calibrated?.p_bucket ? "cal" : "raw";
    }

    const top = [...shownBucket].sort((a, b) => Number(b.probability || 0) - Number(a.probability || 0)).slice(0, 6);
    const blend = Number(n?.calibrated?.blend_weight);
    const blendTxt = Number.isFinite(blend) ? `blend ${Math.round(blend * 100)}% market` : "raw";
    const requestedDate = n?.requested_target_date || "--";
    const nowcastDate = n?.target_date || "--";
    const warns = (n?.diagnostics?.warnings || []).map((w) => esc(w)).join(", ");
    meta.textContent = `${n.station_id || live.stationId} | view ${view} | conf ${pct(n.confidence,1)} | tmax ${num(n.tmax_mean_f,1)}F | req ${requestedDate} | nowcast ${nowcastDate} | ${blendTxt}`;
    if (!top.length) { box.innerHTML = '<div class="empty">No bucket probabilities.</div>'; return; }
    const headerBits = [];
    if (view === "model" && top[0]?.label) headerBits.push(`model top ${esc(top[0].label)} ${pct(top[0].probability, 1)}`);
    if (n?.raw_top?.label) headerBits.push(`raw top ${esc(n.raw_top.label)} ${pct(n.raw_top.probability, 1)}`);
    if (n?.calibrated?.top?.label) headerBits.push(`cal top ${esc(n.calibrated.top.label)} ${pct(n.calibrated.top.probability, 1)}`);
    if (n?.observed_max_f !== null && n?.observed_max_f !== undefined) headerBits.push(`observed max ${num(n.observed_max_f, 1)}F`);
    if (warns) headerBits.push(`warn ${warns}`);

    box.innerHTML = `
        ${headerBits.length ? `<div class="muted mono" style="margin-bottom:8px;">${headerBits.join(" | ")}</div>` : ""}
        ${top.map((b) => {
        const p = Number(b.probability || 0);
        return `<div style="margin-bottom:8px;">
            <div style="display:flex;justify-content:space-between;font-size:12px;">
                <span class="mono">${esc(b.label || "--")}</span><span class="mono">${pct(p,1)}</span>
            </div>
            <div class="bar-wrap"><div class="bar" style="width:${Math.max(0, Math.min(p*100, 100)).toFixed(1)}%"></div></div>
        </div>`;
    }).join("")}`;
}

function renderMarket(m) {
    const meta = document.getElementById("market-meta");
    const box = document.getElementById("market-box");
    if (!m || m.error) {
        meta.textContent = "no market";
        box.innerHTML = `<div class="empty">${esc(m?.error || "No market data.")}</div>`;
        return;
    }
    const nycNow = formatDateTimeInTz(new Date(), "America/New_York");
    const esNow = formatDateTimeInTz(new Date(), "Europe/Madrid");
    meta.textContent = `${m.station_id || live.stationId} | station date ${m.target_date || "--"} | ws:${m.ws_connected ? "on" : "off"} | NYC ${nycNow} | ES ${esNow}`;
    const rows = (m.brackets || []).slice(0, 8);
    if (!rows.length) { box.innerHTML = '<div class="empty">No brackets in market.</div>'; return; }
    box.innerHTML = `
        <div class="market-table-wrap">
            <table class="market-table">
                <colgroup>
                    <col class="bracket">
                    <col class="yes-col">
                    <col class="no-col">
                    <col class="ob-yes-col">
                    <col class="ob-no-col">
                    <col class="spread-col">
                </colgroup>
                <thead>
                    <tr>
                        <th>Bracket</th>
                        <th>YES</th>
                        <th>NO</th>
                        <th>OB YES</th>
                        <th>OB NO</th>
                        <th>Spread Y/N</th>
                    </tr>
                </thead>
                <tbody>
                    ${rows.map((b) => {
                        const yesBid = firstNum(b.ws_yes_best_bid, b.ws_best_bid);
                        const yesAsk = firstNum(b.ws_yes_best_ask, b.ws_best_ask);
                        const yesMidFromBook = (yesBid !== null && yesAsk !== null) ? ((yesBid + yesAsk) / 2) : null;
                        const yesMid = firstNum(b.ws_yes_mid, b.ws_mid, yesMidFromBook, b.yes_price);

                        const noBidRaw = firstNum(b.ws_no_best_bid);
                        const noAskRaw = firstNum(b.ws_no_best_ask);
                        const noBid = firstNum(noBidRaw, yesAsk !== null ? (1.0 - yesAsk) : null);
                        const noAsk = firstNum(noAskRaw, yesBid !== null ? (1.0 - yesBid) : null);
                        const noMidFromBook = (noBid !== null && noAsk !== null) ? ((noBid + noAsk) / 2) : null;
                        const noMid = firstNum(b.ws_no_mid, noMidFromBook, yesMid !== null ? (1.0 - yesMid) : null, b.no_price);

                        const hasWsYes = firstNum(b.ws_yes_mid, b.ws_mid, yesMidFromBook) !== null;
                        const hasWsNo = firstNum(b.ws_no_mid, noMidFromBook) !== null;

                        const yesLiveRaw = yesMid !== null ? yesMid : Number(b.yes_price || 0);
                        const yesLive = Math.max(0, Math.min(1, yesLiveRaw));
                        const noLive = Math.max(0, Math.min(1, noMid !== null ? noMid : (1 - yesLive)));

                        const yesSpread = firstNum(b.ws_yes_spread, b.ws_spread, (yesBid !== null && yesAsk !== null) ? (yesAsk - yesBid) : null);
                        const noSpread = firstNum(b.ws_no_spread, (noBid !== null && noAsk !== null) ? (noAsk - noBid) : null);
                        const spreadText = `${yesSpread !== null ? `${(yesSpread * 100).toFixed(2)}c` : "--"} / ${noSpread !== null ? `${(noSpread * 100).toFixed(2)}c` : "--"}`;

                        const obYes = fmtBookPair(yesBid, yesAsk);
                        const obNo = fmtBookPair(noBid, noAsk);
                        const source = `Y:${hasWsYes ? "ws" : "gamma"} N:${hasWsNo ? "ws" : "derived"}`;
                        return `<tr>
                            <td class="market-name" title="${esc(b.name || "")}">${esc(b.name || "--")}<span class="market-source">${source}</span></td>
                            <td class="yes">${(yesLive * 100).toFixed(1)}c</td>
                            <td class="no">${(noLive * 100).toFixed(1)}c</td>
                            <td class="mono">${obYes}</td>
                            <td class="mono">${obNo}</td>
                            <td class="spread">${spreadText}</td>
                        </tr>`;
                    }).join("")}
                </tbody>
            </table>
        </div>`;
}

function normLabel(label) {
    if (!label) return "";
    let s = String(label).trim();
    s = s.replaceAll("", "");
    s = s.replace(/\s+/g, " ");
    const lower = s.toLowerCase();

    const num = (() => {
        const m = s.match(/-?\d+/);
        return m ? parseInt(m[0], 10) : null;
    })();

    if (lower.includes("or below") && num !== null) return `${num}F or below`;
    if ((lower.includes("or higher") || lower.includes("or above")) && num !== null) return `${num}F or higher`;
    if (lower.startsWith("<") && num !== null) return `${num}F or below`;
    if ((lower.startsWith(">") || lower.startsWith("")) && num !== null) return `${num}F or higher`;

    const range = s.match(/(-?\d+)\s*-\s*(-?\d+)/);
    if (range) {
        const lo = parseInt(range[1], 10);
        const hi = parseInt(range[2], 10);
        if (!Number.isNaN(lo) && !Number.isNaN(hi)) return `${lo}-${hi}F`;
    }

    if (num !== null && !Number.isNaN(num)) return `${num}F`;
    return s;
}

function parseLabel(label) {
    const s = normLabel(label);
    const lower = s.toLowerCase();
    const m = s.match(/-?\d+/);
    const n = m ? parseInt(m[0], 10) : null;

    if (lower.includes("or below") && n !== null) return { kind: "below", low: null, high: n };
    if ((lower.includes("or higher") || lower.includes("or above")) && n !== null) return { kind: "above", low: n, high: null };

    const range = s.match(/(-?\d+)\s*-\s*(-?\d+)/);
    if (range) {
        const lo = parseInt(range[1], 10);
        const hi = parseInt(range[2], 10);
        if (!Number.isNaN(lo) && !Number.isNaN(hi)) return { kind: "range", low: lo, high: hi };
    }

    if (n !== null && !Number.isNaN(n)) return { kind: "single", low: n, high: n };
    return { kind: "unknown", low: null, high: null };
}

function _alignedObservedMax(observedMaxF) {
    const v = Number(observedMaxF);
    if (!Number.isFinite(v)) return null;
    // Round to integer F consistent with settlement approximations.
    return Math.round(v);
}

function isImpossibleWithObservedMax(label, observedMaxF) {
    const aligned = _alignedObservedMax(observedMaxF);
    if (aligned === null) return false;
    const p = parseLabel(label);
    if (!p || p.kind === "unknown") return false;
    // Buckets strictly below the observed max are impossible; equality is still possible.
    if ((p.kind === "range" || p.kind === "below") && p.high !== null) return Number(p.high) < aligned;
    if (p.kind === "single" && p.low !== null) return Number(p.low) < aligned;
    return false;
}

function sortLabels(labels) {
    const key = (label) => {
        const p = parseLabel(label);
        if (p.kind === "below") return [0, p.high ?? -999];
        if (p.kind === "range" || p.kind === "single") return [1, p.low ?? 0];
        if (p.kind === "above") return [2, p.low ?? 999];
        return [3, 0];
    };
    return [...labels].sort((a, b) => {
        const ka = key(a);
        const kb = key(b);
        if (ka[0] !== kb[0]) return ka[0] - kb[0];
        return ka[1] - kb[1];
    });
}

function resolveBooks(bracket) {
    const yesBid = firstNum(bracket?.ws_yes_best_bid, bracket?.ws_best_bid);
    const yesAsk = firstNum(bracket?.ws_yes_best_ask, bracket?.ws_best_ask);
    const yesMidFromBook = (yesBid !== null && yesAsk !== null) ? ((yesBid + yesAsk) / 2) : null;
    const yesMidRaw = firstNum(bracket?.ws_yes_mid, bracket?.ws_mid, yesMidFromBook, bracket?.yes_price);
    const yesMid = yesMidRaw === null ? null : Math.max(0, Math.min(1, Number(yesMidRaw)));

    const noBidRaw = firstNum(bracket?.ws_no_best_bid);
    const noAskRaw = firstNum(bracket?.ws_no_best_ask);
    const noBid = firstNum(noBidRaw, yesAsk !== null ? (1.0 - yesAsk) : null);
    const noAsk = firstNum(noAskRaw, yesBid !== null ? (1.0 - yesBid) : null);
    const noMidFromBook = (noBid !== null && noAsk !== null) ? ((noBid + noAsk) / 2) : null;
    const noMidRaw = firstNum(bracket?.ws_no_mid, noMidFromBook, yesMid !== null ? (1.0 - yesMid) : null, bracket?.no_price);
    const noMid = noMidRaw === null ? null : Math.max(0, Math.min(1, Number(noMidRaw)));

    return {
        yesBid, yesAsk, yesMid,
        noBid, noAsk, noMid,
    };
}

function logisticCdf(x, mean, sigma) {
    const s = Math.max(1e-6, Number(sigma) * 0.5513);
    const z = (Number(x) - Number(mean)) / s;
    if (z > 60) return 1.0;
    if (z < -60) return 0.0;
    return 1.0 / (1.0 + Math.exp(-z));
}

function modelProbForLabel(label, mean, sigma) {
    const p = parseLabel(label);
    if (!p || p.kind === "unknown") return NaN;

    // Polymarket settles on integer F (round half-up). We approximate by integrating
    // over half-integer boundaries.
    if (p.kind === "range" && p.low !== null && p.high !== null) {
        const a = Number(p.low) - 0.5;
        const b = Number(p.high) + 0.5;
        return Math.max(0.0, logisticCdf(b, mean, sigma) - logisticCdf(a, mean, sigma));
    }
    if (p.kind === "single" && p.low !== null) {
        const a = Number(p.low) - 0.5;
        const b = Number(p.low) + 0.5;
        return Math.max(0.0, logisticCdf(b, mean, sigma) - logisticCdf(a, mean, sigma));
    }
    if (p.kind === "below" && p.high !== null) {
        const b = Number(p.high) + 0.5;
        return Math.max(0.0, logisticCdf(b, mean, sigma));
    }
    if (p.kind === "above" && p.low !== null) {
        const a = Number(p.low) - 0.5;
        return Math.max(0.0, 1.0 - logisticCdf(a, mean, sigma));
    }
    return NaN;
}

function renderEdge(n, m) {
    const meta = document.getElementById("edge-meta");
    const box = document.getElementById("edge-box");
    if (!n || n.error) {
        meta.textContent = "no nowcast";
        box.innerHTML = `<div class="empty">${esc(n?.error || "No nowcast data.")}</div>`;
        return;
    }
    if (!m || m.error) {
        meta.textContent = "no market";
        box.innerHTML = `<div class="empty">${esc(m?.error || "No market data.")}</div>`;
        return;
    }

    const mean = Number(n?.tmax_mean_f);
    const sigma = Number(n?.tmax_sigma_f ?? n?.tmax_sigma ?? 0.0);
    const calBucket = Array.isArray(n?.calibrated?.p_bucket) ? n.calibrated.p_bucket : [];
    if (!Number.isFinite(mean) || Number.isNaN(mean)) {
        meta.textContent = `${n.station_id || live.stationId} | invalid nowcast`;
        box.innerHTML = `<div class="empty">Nowcast missing tmax_mean.</div>`;
        return;
    }

    const calMap = {};
    for (const b of calBucket) {
        const label = normLabel(b?.label);
        const prob = Number(b?.probability ?? b?.prob ?? 0);
        if (!label || Number.isNaN(prob)) continue;
        calMap[label] = prob;
    }

    const brackets = Array.isArray(m?.brackets) ? m.brackets : [];
    const marketByLabel = {};
    let maxYes = 0.0;
    for (const b of brackets) {
        const label = normLabel(b?.name);
        if (!label) continue;
        marketByLabel[label] = b;
        const book = resolveBooks(b);
        if (book.yesMid !== null) maxYes = Math.max(maxYes, Number(book.yesMid));
    }
    const resolved = maxYes >= 0.98;

    const labels = sortLabels(Object.keys(marketByLabel));
    const MIN_EDGE = 0.05;
    meta.textContent =
        `${n.station_id || live.stationId} | nowcast ${n.target_date || "--"} | market ${m.target_date || "--"} | conf ${pct(n.confidence, 1)} | resolved ${resolved ? "yes" : "no"}`;

    // Build a normalized model distribution over the market's tradable brackets.
    const modelMap = {};
    let modelTotal = 0.0;
    const observedMax = Number(n?.observed_max_f);
    const hasObservedMax = Number.isFinite(observedMax);
    for (const label of labels) {
        let p = modelProbForLabel(label, mean, sigma);
        if (!Number.isFinite(p) || Number.isNaN(p)) continue;
        if (hasObservedMax && isImpossibleWithObservedMax(label, observedMax)) p = 0.0;
        modelMap[label] = p;
        modelTotal += p;
    }
    if (modelTotal > 0) {
        for (const label of Object.keys(modelMap)) {
            modelMap[label] = modelMap[label] / modelTotal;
        }
    }

    box.innerHTML = `
        <div class="table-wrap">
            <table class="table edge-table">
                <colgroup>
                    <col class="bracket">
                    <col class="model-col">
                    <col class="market-col">
                    <col class="ob-col">
                    <col class="edge-col">
                    <col class="action-col">
                    <col class="ev-col">
                </colgroup>
                <thead>
                    <tr>
                        <th>Bracket</th>
                        <th>Model</th>
                        <th>Market</th>
                        <th>OB YES</th>
                        <th>Edge</th>
                        <th>Action</th>
                        <th>EV</th>
                    </tr>
                </thead>
                <tbody>
                    ${labels.map((label) => {
                        const model = Number(modelMap[label] ?? NaN);
                        const modelCal = Number(calMap[label] ?? NaN);
                        const bracket = marketByLabel[label];
                        const book = bracket ? resolveBooks(bracket) : { yesBid: null, yesAsk: null, yesMid: null, noAsk: null, noMid: null };

                        const market = book.yesMid !== null ? Number(book.yesMid) : null;
                        const edge = (market !== null && !Number.isNaN(model)) ? (model - market) : null;

                        let action = "--";
                        let actionCls = "hold";
                        if (resolved) {
                            action = "RESOLVED";
                            actionCls = "hold";
                        } else if (edge !== null) {
                            if (edge >= MIN_EDGE) { action = "BUY YES"; actionCls = "buy"; }
                            else if (edge <= -MIN_EDGE) { action = "BUY NO"; actionCls = "sell"; }
                            else { action = "HOLD"; actionCls = "hold"; }
                        }

                        let ev = null;
                        if (!resolved && edge !== null) {
                            if (action === "BUY YES") {
                                const px = book.yesAsk !== null ? Number(book.yesAsk) : (market !== null ? market : null);
                                if (px !== null) ev = model - px;
                            } else if (action === "BUY NO") {
                                const modelNo = 1.0 - model;
                                const px = book.noAsk !== null ? Number(book.noAsk) : (book.noMid !== null ? Number(book.noMid) : (market !== null ? (1.0 - market) : null));
                                if (px !== null) ev = modelNo - px;
                            }
                        }

                        const edgeTxt = edge === null ? "--" : `${(edge * 100).toFixed(1)}c`;
                        const edgeCls = edge === null ? "" : (edge > 0 ? "pos" : (edge < 0 ? "neg" : ""));
                        const modelTxt = Number.isNaN(model) ? "--" : `${(model * 100).toFixed(1)}c`;
                        const marketTxt = market === null ? "--" : `${(market * 100).toFixed(1)}c`;
                        const obYes = fmtBookPair(book.yesBid, book.yesAsk);
                        const evTxt = ev === null ? "--" : `${(ev * 100).toFixed(1)}c`;
                        const titleBits = [];
                        if (!Number.isNaN(modelCal)) titleBits.push(`cal ${(modelCal * 100).toFixed(1)}c`);
                        if (titleBits.length) titleBits.push(`minEdge ${(MIN_EDGE * 100).toFixed(0)}c`);
                        return `<tr title="${esc(titleBits.join(" | "))}">
                            <td class="mono">${esc(label)}</td>
                            <td class="mono">${modelTxt}</td>
                            <td class="mono">${marketTxt}</td>
                            <td class="mono">${obYes}</td>
                            <td class="mono ${edgeCls}">${edgeTxt}</td>
                            <td class="edge-action ${actionCls}">${esc(action)}</td>
                            <td class="mono">${evTxt}</td>
                        </tr>`;
                    }).join("")}
                </tbody>
            </table>
        </div>`;
}

function renderIntraday(payload) {
    const meta = document.getElementById("intraday-meta");
    const submeta = document.getElementById("intraday-submeta");
    const canvas = document.getElementById("intraday-chart");
    if (!canvas) return;

    if (live.intradayChart) {
        live.intradayChart.destroy();
        live.intradayChart = null;
    }

    if (!payload || payload.error) {
        meta.textContent = "intraday unavailable";
        submeta.textContent = payload?.error || "No intraday payload";
        return;
    }

    const rawTimeline = Array.isArray(payload.timeline) ? payload.timeline : [];
    const fills = Array.isArray(payload.fills) ? payload.fills : [];
    const marketSeries = Array.isArray(payload.market_series) ? payload.market_series : [];
    if (!rawTimeline.length) {
        meta.textContent = "no intraday decisions";
        submeta.textContent = `target ${payload?.window?.target_date || "--"} | fills ${fills.length}`;
        return;
    }
    const MAX_PLOTTED_DECISIONS = 300;
    const step = Math.max(1, Math.ceil(rawTimeline.length / MAX_PLOTTED_DECISIONS));
    const timeline = rawTimeline.filter((_, idx) => idx % step === 0);

    const labels = [];
    const means = [];
    const upper = [];
    const lower = [];
    const timeMs = [];
    const buySignalPts = [];
    const sellSignalPts = [];

    for (let i = 0; i < timeline.length; i += 1) {
        const p = timeline[i] || {};
        const ts = p.ts_utc || p.ts_nyc;
        const ms = toMillis(ts);
        timeMs.push(ms);
        labels.push(ts ? formatDateTimeInTz(ts, live.stationTz).slice(11, 16) : `#${i + 1}`);

        const mean = Number(p.tmax_mean_f);
        const sigma = Number(p.tmax_sigma_f || 0);
        means.push(Number.isNaN(mean) ? null : mean);
        upper.push(Number.isNaN(mean) ? null : (mean + (Number.isNaN(sigma) ? 0 : sigma)));
        lower.push(Number.isNaN(mean) ? null : (mean - (Number.isNaN(sigma) ? 0 : sigma)));

        const actions = Array.isArray(p.actions) ? p.actions : [];
        for (const a of actions) {
            const side = String(a?.side || "").toLowerCase();
            const y = Number.isNaN(mean) ? null : mean;
            if (y === null) continue;
            if (side === "buy") buySignalPts.push({ x: i, y });
            if (side === "sell") sellSignalPts.push({ x: i, y });
        }
    }

    const nearestIndex = (ms) => {
        if (ms === null || ms === undefined || !timeMs.length) return null;
        let bestIdx = null;
        let bestDist = Infinity;
        for (let i = 0; i < timeMs.length; i += 1) {
            const t = timeMs[i];
            if (t === null || t === undefined) continue;
            const d = Math.abs(t - ms);
            if (d < bestDist) {
                bestDist = d;
                bestIdx = i;
            }
        }
        return bestIdx;
    };

    const buyFillPts = [];
    const sellFillPts = [];
    for (const f of fills) {
        const idx = nearestIndex(toMillis(f.ts_utc));
        if (idx === null) continue;
        const y = means[idx];
        if (y === null || y === undefined) continue;
        const side = String(f.side || "").toLowerCase();
        if (side === "buy") buyFillPts.push({ x: idx, y });
        if (side === "sell") sellFillPts.push({ x: idx, y });
    }

    const marketTopSeries = Array(labels.length).fill(null);
    for (const m of marketSeries) {
        const idx = nearestIndex(toMillis(m.ts_utc));
        if (idx === null) continue;
        const p = Number(m.market_top1_prob);
        if (!Number.isNaN(p)) marketTopSeries[idx] = p;
    }

    const datasets = [
        {
            label: "Tmax Mean",
            data: means,
            borderColor: "#0078FF",
            backgroundColor: "transparent",
            borderWidth: 2,
            tension: 0.25,
            pointRadius: 0,
            order: 5,
        },
        {
            label: "+1sigma",
            data: upper,
            borderColor: "transparent",
            backgroundColor: "rgba(0, 120, 255, 0.12)",
            pointRadius: 0,
            fill: "+1",
            order: 6,
        },
        {
            label: "-1sigma",
            data: lower,
            borderColor: "transparent",
            backgroundColor: "rgba(0, 120, 255, 0.12)",
            pointRadius: 0,
            fill: false,
            order: 6,
        },
    ];

    const observedRaw = payload?.observed_max_f;
    const observed = (observedRaw === null || observedRaw === undefined) ? Number.NaN : Number(observedRaw);
    if (!Number.isNaN(observed)) {
        datasets.push({
            label: "Observed Max So Far",
            data: Array(labels.length).fill(observed),
            borderColor: "#F59E0B",
            borderDash: [6, 4],
            borderWidth: 1.5,
            pointRadius: 0,
            fill: false,
            order: 4,
        });
    }
    if (buySignalPts.length) {
        datasets.push({
            label: "Buy Signal",
            data: buySignalPts,
            type: "scatter",
            yAxisID: "y",
            backgroundColor: "#10B981",
            borderColor: "#10B981",
            pointRadius: 5,
            pointStyle: "triangle",
            order: 2,
        });
    }
    if (sellSignalPts.length) {
        datasets.push({
            label: "Sell Signal",
            data: sellSignalPts,
            type: "scatter",
            yAxisID: "y",
            backgroundColor: "#EF4444",
            borderColor: "#EF4444",
            pointRadius: 5,
            pointStyle: "triangle",
            rotation: 180,
            order: 2,
        });
    }
    if (buyFillPts.length) {
        datasets.push({
            label: "Buy Fill",
            data: buyFillPts,
            type: "scatter",
            yAxisID: "y",
            backgroundColor: "#00E676",
            borderColor: "#F8FAFC",
            pointBorderWidth: 1.8,
            pointRadius: 6.5,
            pointHoverRadius: 8,
            pointStyle: "rectRot",
            order: 1,
        });
    }
    if (sellFillPts.length) {
        datasets.push({
            label: "Sell Fill",
            data: sellFillPts,
            type: "scatter",
            yAxisID: "y",
            backgroundColor: "#FF1744",
            borderColor: "#F8FAFC",
            pointBorderWidth: 1.8,
            pointRadius: 6.5,
            pointHoverRadius: 8,
            pointStyle: "rectRot",
            order: 1,
        });
    }
    if (marketTopSeries.some((v) => v !== null)) {
        datasets.push({
            label: "Market Top1 Prob",
            data: marketTopSeries,
            yAxisID: "yProb",
            borderColor: "#A78BFA",
            borderWidth: 1.25,
            borderDash: [3, 3],
            pointRadius: 0,
            tension: 0.2,
            fill: false,
            order: 3,
        });
    }

    const ctx = canvas.getContext("2d");
    live.intradayChart = new Chart(ctx, {
        type: "line",
        data: { labels, datasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: { mode: "index", intersect: false },
            plugins: {
                legend: {
                    labels: {
                        color: "#94a3b8",
                        font: { size: 11, family: "JetBrains Mono" },
                    },
                },
            },
            scales: {
                x: {
                    grid: { color: "rgba(148,163,184,0.12)" },
                    ticks: { color: "#94a3b8", maxRotation: 0, autoSkip: true, maxTicksLimit: 10 },
                },
                y: {
                    grid: { color: "rgba(148,163,184,0.12)" },
                    ticks: { color: "#94a3b8" },
                    title: { display: true, text: "Tmax (F)", color: "#94a3b8" },
                },
                yProb: {
                    position: "right",
                    min: 0,
                    max: 1,
                    grid: { drawOnChartArea: false },
                    ticks: {
                        color: "#a78bfa",
                        callback: (v) => `${Math.round(Number(v) * 100)}%`,
                    },
                    title: { display: true, text: "Top1 Prob", color: "#a78bfa" },
                },
            },
        },
    });

    const actionTicks = rawTimeline.filter((p) => Array.isArray(p?.actions) && p.actions.length > 0).length;
    meta.textContent = `${payload?.window?.target_date || "--"} | decisions ${rawTimeline.length} (chart ${timeline.length}) | action ticks ${actionTicks} | orders ${payload?.counts?.orders || 0} | fills ${fills.length}`;
    const marketPts = marketSeries.length;
    submeta.textContent =
        `cada decision = tick de evaluacion; orders/fills solo cuando ejecuta | observed max ${Number.isNaN(observed) ? "--" : `${observed.toFixed(1)}F`} | market points ${marketPts}`;
}

async function refreshFast() {
    const [statusR, decisionsR, positionsR, strategiesR, ordersR, fillsR] = await Promise.allSettled([
        j("/api/v6/autotrader/status"),
        j("/api/v6/autotrader/decisions?limit=120"),
        j("/api/v6/autotrader/positions"),
        j("/api/v6/autotrader/strategies"),
        j("/api/v6/autotrader/orders?limit=40"),
        j("/api/v6/autotrader/fills?limit=40"),
    ]);

    if (statusR.status !== "fulfilled") {
        throw new Error(`status unavailable: ${statusR.reason?.message || "unknown error"}`);
    }

    const status = statusR.value;
    const decisions = decisionsR.status === "fulfilled" ? (decisionsR.value.decisions || []) : [];
    const positions = positionsR.status === "fulfilled" ? (positionsR.value.positions || {}) : {};
    const strategies = strategiesR.status === "fulfilled" ? (strategiesR.value.strategies || []) : [];
    const orders = ordersR.status === "fulfilled" ? (ordersR.value.orders || []) : [];
    const fills = fillsR.status === "fulfilled" ? (fillsR.value.fills || []) : [];

    const degraded = [
        decisionsR.status === "rejected" ? "decisions" : "",
        positionsR.status === "rejected" ? "positions" : "",
        strategiesR.status === "rejected" ? "strategies" : "",
        ordersR.status === "rejected" ? "orders" : "",
        fillsR.status === "rejected" ? "fills" : "",
    ].filter(Boolean);

    renderStatus(status, decisions, positions, strategies);
    renderSignals(decisions);
    renderMini(fills, "fills-box", "fills");
    renderMini(orders, "orders-box", "orders");

    if (degraded.length) {
        setControlMessage(`updated ${new Date().toLocaleTimeString()} (partial: ${degraded.join(", ")})`, "warn");
    } else {
        setControlMessage(`updated ${new Date().toLocaleTimeString()}`);
    }
}

async function refreshSlow() {
    const s = live.stationId || "KLGA";
    const [n, m, intraday] = await Promise.allSettled([
        j(`/api/v6/autotrader/nowcast?target_day=${live.targetDay}`),
        j(`/api/polymarket/${s}?target_day=${live.targetDay}&depth=5`),
        j(`/api/v6/autotrader/intraday?target_day=${live.targetDay}&limit=1000`),
    ]);
    const nowcastPayload = n.status === "fulfilled" ? n.value : { error: n.reason?.message || "error" };
    const marketPayload = m.status === "fulfilled" ? m.value : { error: m.reason?.message || "error" };
    renderNowcast(nowcastPayload, marketPayload);
    renderMarket(marketPayload);
    renderEdge(nowcastPayload, marketPayload);
    renderIntraday(intraday.status === "fulfilled" ? intraday.value : { error: intraday.reason?.message || "error" });
}

async function manualRefresh() {
    const [fast, slow] = await Promise.allSettled([refreshFast(), refreshSlow()]);
    if (fast.status === "rejected") {
        setControlMessage(`refresh error: ${fast.reason?.message || "fast loop failed"}`, "error");
    } else if (slow.status === "rejected") {
        setControlMessage(`slow refresh warning: ${slow.reason?.message || "slow loop failed"}`, "warn");
    }
}

async function sendControl(action) {
    if (live.pendingAction) return;
    live.pendingAction = action;
    setControlsDisabled(true);
    const actionBtnId = {
        start: "btn-start",
        pause: "btn-pause",
        resume: "btn-resume",
        risk_off: "btn-riskoff",
        risk_on: "btn-riskon",
    }[action];
    if (actionBtnId) document.getElementById(actionBtnId)?.classList.add("active");
    setControlMessage(`sending ${action}...`);
    try {
        const r = await fetch("/api/v6/autotrader/control", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ action }),
        });
        const data = await r.json();
        if (!r.ok || data.ok === false) {
            throw new Error(data.error || "control failed");
        }
        if (data.status) {
            renderStatus(data.status, [], {}, []);
        }
        setControlMessage(`action ${action} OK @ ${new Date().toLocaleTimeString()}`);
        await manualRefresh();
    } catch (err) {
        setControlMessage(`control error (${action}): ${err.message}`, "error");
    } finally {
        if (live.lastStatus) setControlActive(live.lastStatus);
        else setControlsDisabled(false);
        live.pendingAction = null;
    }
}

function startPolling() {
    if (live.fastTimer) clearInterval(live.fastTimer);
    if (live.slowTimer) clearInterval(live.slowTimer);
    live.fastTimer = setInterval(() => refreshFast().catch((e) => {
        setControlMessage(`fast loop error: ${e.message}`, "error");
    }), 5000);
    live.slowTimer = setInterval(() => refreshSlow().catch((e) => {
        setControlMessage(`slow loop error: ${e.message}`, "warn");
    }), 5000);
}

function onMarketDayChange() {
    const select = document.getElementById("market-day-select");
    live.targetDay = Number(select.value || 0);
    updateMarketDayMeta();
    setControlMessage(`market day changed to D+${live.targetDay}; refreshing...`);
    manualRefresh();
}

async function onStationChange(stationId) {
    const normalized = window.HeliosStationState?.normalize?.(stationId) || String(stationId || "").toUpperCase();
    if (!normalized) return;
    if (live.pendingAction) return;
    if ((live.lastStatus?.station_id || live.stationId) === normalized) {
        live.stationId = normalized;
        live.stationTz = STATION_TIMEZONES[normalized] || "America/New_York";
        window.HeliosStationState?.set?.(normalized, { source: "autotrader" });
        const sel = document.getElementById("station-select");
        if (sel && sel.value !== normalized) sel.value = normalized;
        return;
    }
    setControlMessage(`Switching to ${normalized}...`);
    try {
        const r = await fetch("/api/v6/autotrader/control", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({action: "change_station", station_id: normalized}),
        });
        const data = await r.json();
        if (data.ok) {
            live.stationId = normalized;
            live.stationTz = STATION_TIMEZONES[normalized] || "America/New_York";
            window.HeliosStationState?.set?.(normalized, { source: "autotrader" });
            const sel = document.getElementById("station-select");
            if (sel && sel.value !== normalized) sel.value = normalized;
            setControlMessage(`Switched to ${normalized}`, "ok");
            manualRefresh();
        } else {
            setControlMessage(`Error: ${data.error}`, "warn");
        }
    } catch (e) {
        setControlMessage(`Station switch failed: ${e.message}`, "warn");
    }
}

document.addEventListener("visibilitychange", () => { if (!document.hidden) manualRefresh(); });
document.addEventListener("DOMContentLoaded", async () => {
    const initialGlobalStation = window.HeliosStationState?.get?.();
    const sel = document.getElementById("station-select");
    if (sel && initialGlobalStation && Array.from(sel.options).some(o => o.value === initialGlobalStation)) {
        sel.value = initialGlobalStation;
        live.stationId = initialGlobalStation;
        live.stationTz = STATION_TIMEZONES[initialGlobalStation] || "America/New_York";
    }

    window.addEventListener("helios:stationchange", async (event) => {
        const nextStation = event?.detail?.stationId;
        if (!nextStation) return;
        if (live.pendingAction) return;
        if ((live.lastStatus?.station_id || live.stationId) === nextStation) {
            if (sel && sel.value !== nextStation) sel.value = nextStation;
            live.stationId = nextStation;
            live.stationTz = STATION_TIMEZONES[nextStation] || "America/New_York";
            return;
        }
        await onStationChange(nextStation);
    });

    live.targetDay = Number(document.getElementById("market-day-select").value || 0);
    updateMarketDayMeta();
    await manualRefresh();
    // Sync station selector with actual service station
    if (sel && live.lastStatus?.station_id) {
        sel.value = live.lastStatus.station_id;
        live.stationId = live.lastStatus.station_id;
        live.stationTz = STATION_TIMEZONES[live.stationId] || "America/New_York";
    }
    if (initialGlobalStation && live.stationId !== initialGlobalStation) {
        await onStationChange(initialGlobalStation);
    }
    startPolling();
});
window.sendControl = sendControl;
window.manualRefresh = manualRefresh;
window.onMarketDayChange = onMarketDayChange;
window.onStationChange = onStationChange;
</script>
{% endblock %}
