{% extends "base.html" %}

{% block title %}HELIOS - Nowcast Engine{% endblock %}

{% block head_extra %}
<style>
    .nowcast-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 20px;
    }

    .nowcast-panel {
        background: var(--bg-secondary);
        border: 1px solid rgba(255,255,255,0.05);
        border-radius: 12px;
        padding: 20px;
    }

    .nowcast-panel-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .nowcast-panel-title {
        font-size: 14px;
        font-weight: 600;
        color: var(--text-main);
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .nowcast-panel-title i {
        width: 18px;
        height: 18px;
        color: var(--accent-blue);
    }

    /* Central Estimate Card */
    .estimate-card {
        background: linear-gradient(135deg, rgba(0,120,255,0.15), rgba(0,212,255,0.05));
        border: 1px solid rgba(0,120,255,0.3);
        border-radius: 16px;
        padding: 25px;
        text-align: center;
        margin-bottom: 20px;
    }

    .estimate-label {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--text-muted);
        margin-bottom: 8px;
    }

    .estimate-value {
        font-size: 48px;
        font-weight: 700;
        font-family: 'JetBrains Mono', monospace;
        color: #0078FF;
        line-height: 1;
    }

    .estimate-uncertainty {
        font-size: 14px;
        color: var(--text-secondary);
        margin-top: 8px;
    }

    .estimate-confidence {
        display: inline-block;
        padding: 4px 12px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        margin-top: 12px;
    }

    .confidence-high { background: rgba(16,185,129,0.2); color: #10B981; }
    .confidence-medium { background: rgba(244,208,63,0.2); color: #F4D03F; }
    .confidence-low { background: rgba(239,68,68,0.2); color: #EF4444; }

    /* Bucket Probability Bars */
    .bucket-container {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .bucket-row {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .bucket-label {
        width: 60px;
        font-size: 12px;
        font-family: 'JetBrains Mono', monospace;
        color: var(--text-secondary);
        text-align: right;
    }

    .bucket-bar-container {
        flex: 1;
        height: 24px;
        background: rgba(255,255,255,0.03);
        border-radius: 4px;
        overflow: hidden;
        position: relative;
    }

    .bucket-bar {
        height: 100%;
        background: linear-gradient(90deg, #0078FF, #00d4ff);
        border-radius: 4px;
        transition: width 0.5s ease;
    }

    .bucket-bar.impossible {
        background: rgba(239,68,68,0.3);
    }

    .bucket-prob {
        width: 50px;
        font-size: 12px;
        font-family: 'JetBrains Mono', monospace;
        color: var(--text-main);
        text-align: left;
    }

    /* t_peak Histogram */
    .tpeak-histogram {
        display: flex;
        align-items: flex-end;
        justify-content: space-between;
        height: 120px;
        padding: 10px 0;
        gap: 4px;
    }

    .tpeak-bar-wrapper {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        height: 100%;
    }

    .tpeak-bar {
        width: 100%;
        background: linear-gradient(180deg, #8B5CF6, #6366F1);
        border-radius: 4px 4px 0 0;
        transition: height 0.5s ease;
    }

    .tpeak-bar.past {
        background: rgba(100,100,100,0.3);
    }

    .tpeak-label {
        font-size: 10px;
        color: var(--text-muted);
        margin-top: 4px;
        font-family: 'JetBrains Mono', monospace;
        text-align: center;
        line-height: 1.3;
    }

    .tpeak-label-nyc {
        color: var(--text-secondary);
        font-weight: 500;
    }

    .tpeak-label-es {
        font-size: 8px;
        color: var(--text-muted);
        opacity: 0.7;
    }

    /* Stats Grid */
    .stats-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 15px;
        margin-bottom: 20px;
    }

    .stat-card {
        background: rgba(255,255,255,0.02);
        border: 1px solid rgba(255,255,255,0.05);
        border-radius: 10px;
        padding: 15px;
        text-align: center;
    }

    .stat-label {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: var(--text-muted);
        margin-bottom: 6px;
    }

    .stat-value {
        font-size: 24px;
        font-weight: 700;
        font-family: 'JetBrains Mono', monospace;
    }

    .stat-value.positive { color: #10B981; }
    .stat-value.negative { color: #EF4444; }
    .stat-value.neutral { color: var(--text-main); }

    /* Explanations */
    .explanation-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .explanation-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
        background: rgba(255,255,255,0.02);
        border-radius: 8px;
        border-left: 3px solid var(--accent-blue);
    }

    .explanation-factor {
        font-size: 11px;
        text-transform: uppercase;
        color: var(--text-muted);
        width: 80px;
    }

    .explanation-desc {
        flex: 1;
        font-size: 13px;
        color: var(--text-main);
    }

    .explanation-value {
        font-size: 14px;
        font-weight: 600;
        font-family: 'JetBrains Mono', monospace;
    }

    /* Station Selector */
    .station-selector {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
    }

    .station-btn {
        padding: 8px 20px;
        background: rgba(255,255,255,0.05);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 8px;
        color: var(--text-secondary);
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
    }

    .station-btn:hover {
        background: rgba(255,255,255,0.1);
    }

    .station-btn.active {
        background: rgba(0,120,255,0.2);
        border-color: var(--accent-blue);
        color: var(--accent-blue);
    }

    /* Update Status */
    .update-status {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 11px;
        color: var(--text-muted);
    }

    .update-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #10B981;
        animation: pulse 2s infinite;
    }

    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
    }

    /* Debug Link */
    .debug-link {
        font-size: 11px;
        color: var(--text-muted);
        text-decoration: none;
        display: flex;
        align-items: center;
        gap: 4px;
    }

    .debug-link:hover {
        color: var(--accent-blue);
    }

    /* Market Info Banner */
    .market-banner {
        display: flex;
        align-items: center;
        justify-content: space-between;
        background: rgba(255,255,255,0.02);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 10px;
        padding: 12px 20px;
        margin-bottom: 20px;
    }

    .market-info {
        display: flex;
        align-items: center;
        gap: 20px;
    }

    .market-date {
        display: flex;
        flex-direction: column;
    }

    .market-date-label {
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--text-muted);
    }

    .market-date-value {
        font-size: 18px;
        font-weight: 700;
        font-family: 'JetBrains Mono', monospace;
        color: var(--text-main);
    }

    .market-time {
        display: flex;
        flex-direction: column;
        padding-left: 20px;
        border-left: 1px solid rgba(255,255,255,0.1);
    }

    .market-time-label {
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--text-muted);
    }

    .market-time-value {
        font-size: 14px;
        font-family: 'JetBrains Mono', monospace;
        color: var(--text-secondary);
    }

    .market-status {
        display: flex;
        align-items: center;
        gap: 15px;
    }

    .market-status-badge {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 6px 14px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
    }

    .market-status-badge.live {
        background: rgba(16,185,129,0.2);
        color: #10B981;
    }

    .market-status-badge.live::before {
        content: '';
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #10B981;
        animation: pulse 2s infinite;
    }

    .market-status-badge.resolved {
        background: rgba(100,100,100,0.3);
        color: var(--text-muted);
    }

    .market-countdown {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
    }

    .market-countdown-label {
        font-size: 10px;
        color: var(--text-muted);
    }

    .market-countdown-value {
        font-size: 14px;
        font-weight: 600;
        font-family: 'JetBrains Mono', monospace;
        color: var(--accent-blue);
    }

    /* Responsive */
    @media (max-width: 1200px) {
        .nowcast-grid {
            grid-template-columns: 1fr;
        }
        .stats-grid {
            grid-template-columns: repeat(2, 1fr);
        }
    }

    .hourly-wrap {
        height: 320px;
        min-height: 240px;
        position: relative;
    }
    .hourly-meta {
        margin-top: 10px;
        font-size: 11px;
        color: var(--text-secondary);
        font-family: 'JetBrains Mono', monospace;
        overflow-wrap: anywhere;
    }
</style>
{% endblock %}

{% block content %}
<div class="page-header">
    <div class="page-title">
        <i data-lucide="activity" style="width:24px;height:24px;color:var(--accent-blue);"></i>
        Nowcast Engine
    </div>
    <div class="update-status">
        <span class="update-dot"></span>
        <span id="last-update">Loading...</span>
        <a href="/nowcast/debug" class="debug-link">
            <i data-lucide="bug" style="width:12px;height:12px;"></i>
            Debug
        </a>
    </div>
</div>

<div class="page-content">
    <!-- Station Selector -->
    <div class="station-selector" id="station-selector">
        <!-- Populated by JS -->
    </div>

    <!-- Market Info Banner -->
    <div class="market-banner">
        <div class="market-info">
            <div class="market-date">
                <span class="market-date-label" id="settlement-date-label">Settlement Date</span>
                <span class="market-date-value" id="market-date">--</span>
            </div>
            <div class="market-time">
                <span class="market-time-label" id="market-time-label">Current Time</span>
                <span class="market-time-value" id="market-time">--:-- (--:--)</span>
            </div>
        </div>
        <div class="market-status">
            <div class="market-countdown" id="market-countdown-container">
                <span class="market-countdown-label">Market closes in</span>
                <span class="market-countdown-value" id="market-countdown">--:--:--</span>
            </div>
            <div class="market-status-badge live" id="market-status-badge">
                LIVE
            </div>
        </div>
    </div>

    <!-- Central Estimate -->
    <div class="estimate-card">
        <div class="estimate-label">Predicted Maximum Temperature</div>
        <div class="estimate-value" id="tmax-mean">--</div>
        <div class="estimate-uncertainty" id="tmax-sigma">Uncertainty: --</div>
        <div class="estimate-confidence confidence-medium" id="confidence-badge">MEDIUM</div>
    </div>

    <!-- Stats Grid -->
    <div class="stats-grid">
        <div class="stat-card">
            <div class="stat-label">Bias Applied</div>
            <div class="stat-value neutral" id="stat-bias">--</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Max Observed</div>
            <div class="stat-value neutral" id="stat-max-observed">--</div>
        </div>
        <div class="stat-card">
            <div class="stat-label" id="stat-peak-label">Expected Peak</div>
            <div class="stat-value neutral" id="stat-peak-hour">--</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Base Forecast</div>
            <div class="stat-value neutral" id="stat-base-source">--</div>
        </div>
    </div>

    <div class="nowcast-grid">
        <!-- Bucket Probabilities -->
        <div class="nowcast-panel">
            <div class="nowcast-panel-header">
                <div class="nowcast-panel-title">
                    <i data-lucide="bar-chart"></i>
                    P(bucket) - Temperature Brackets
                </div>
            </div>
            <div class="bucket-container" id="bucket-container">
                <!-- Populated by JS -->
            </div>
        </div>

        <!-- t_peak Distribution -->
        <div class="nowcast-panel">
                <div class="nowcast-panel-header">
                    <div class="nowcast-panel-title">
                        <i data-lucide="clock"></i>
                        <span id="tpeak-title">t_peak - Time of Maximum (Local)</span>
                    </div>
                </div>
            <div class="tpeak-histogram" id="tpeak-histogram">
                <!-- Populated by JS -->
            </div>
        </div>
    </div>

    <!-- Hourly Temperature Curve -->
    <div class="nowcast-panel">
        <div class="nowcast-panel-header">
            <div class="nowcast-panel-title">
                <i data-lucide="trending-up"></i>
                Hourly Temperature Curve
            </div>
        </div>
        <div class="hourly-wrap">
            <canvas id="hourly-chart"></canvas>
        </div>
        <div class="hourly-meta" id="hourly-meta">--</div>
    </div>

    <!-- Explanations -->
    <div class="nowcast-panel">
        <div class="nowcast-panel-header">
            <div class="nowcast-panel-title">
                <i data-lucide="info"></i>
                Key Factors
            </div>
        </div>
        <div class="explanation-list" id="explanation-list">
            <!-- Populated by JS -->
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
(function() {
    let currentStation = 'KLGA';
    let pollInterval = null;
    let hourlyChart = null;

    // Station timezone + market-unit info
    const stationTimezones = {};    // stationId -> IANA timezone
    const stationMarketUnits = {};  // stationId -> 'F' | 'C'
    const TZ_LABELS = { 'KLGA': 'NYC', 'KATL': 'ATL', 'EGLC': 'LON', 'LTAC': 'ANK' };
    const ES_TZ = 'Europe/Madrid';

    // Dynamic formatters (rebuilt when station changes)
    let localTimeFormatter = null;
    let localDateFormatter = null;
    let localIsoDateFormatter = null;
    let esTimeFormatter = null;
    let localTzLabel = 'NYC';

    function getStationMarketUnit(stationId = currentStation) {
        const raw = String(stationMarketUnits[stationId] || '').toUpperCase();
        if (raw === 'C' || raw === 'CELSIUS') return 'C';
        return (stationId === 'EGLC' || stationId === 'LTAC') ? 'C' : 'F';
    }

    function usesCelsius(stationId = currentStation) {
        return getStationMarketUnit(stationId) === 'C';
    }

    function tempUnitSymbol(stationId = currentStation) {
        return usesCelsius(stationId) ? '°C' : '°F';
    }

    function fToC(tempF) {
        return (Number(tempF) - 32) * (5 / 9);
    }

    function deltaFToC(deltaF) {
        return Number(deltaF) * (5 / 9);
    }

    function convertTempFromF(tempF, stationId = currentStation) {
        if (!Number.isFinite(Number(tempF))) return null;
        const value = Number(tempF);
        return usesCelsius(stationId) ? fToC(value) : value;
    }

    function convertDeltaFromF(deltaF, stationId = currentStation) {
        if (!Number.isFinite(Number(deltaF))) return null;
        const value = Number(deltaF);
        return usesCelsius(stationId) ? deltaFToC(value) : value;
    }

    function formatTempFromF(tempF, digits = 1, stationId = currentStation) {
        const v = convertTempFromF(tempF, stationId);
        if (v == null) return '--';
        return `${v.toFixed(digits)}${tempUnitSymbol(stationId)}`;
    }

    function formatSignedDeltaFromF(deltaF, digits = 1, stationId = currentStation) {
        const v = convertDeltaFromF(deltaF, stationId);
        if (v == null) return '--';
        const sign = v >= 0 ? '+' : '';
        return `${sign}${v.toFixed(digits)}${tempUnitSymbol(stationId)}`;
    }

    function parseBucketBoundsF(label) {
        if (!label) return null;
        const raw = String(label).trim();
        if (!raw) return null;

        const lower = raw.toLowerCase();
        const numbers = raw.match(/-?\d+(?:\.\d+)?/g);
        if (!numbers || numbers.length === 0) return null;

        const isC = /°\s*c/i.test(raw) || /celsius/i.test(lower);
        const toF = (v) => isC ? ((v * 9) / 5) + 32 : v;

        if (lower.includes('or below')) {
            const threshold = toF(Number(numbers[0]));
            return Number.isFinite(threshold) ? { kind: 'below', threshold } : null;
        }
        if (lower.includes('or above') || lower.includes('or higher')) {
            const threshold = toF(Number(numbers[0]));
            return Number.isFinite(threshold) ? { kind: 'above', threshold } : null;
        }
        if (numbers.length >= 2) {
            const low = toF(Number(numbers[0]));
            const high = toF(Number(numbers[1]));
            if (Number.isFinite(low) && Number.isFinite(high)) return { kind: 'range', low, high };
        }
        const single = toF(Number(numbers[0]));
        if (Number.isFinite(single)) return { kind: 'single', value: single };
        return null;
    }

    function formatBucketLabelForStation(bucket) {
        const raw = bucket && bucket.label ? String(bucket.label).trim() : '';
        if (!usesCelsius()) {
            if (raw) return raw.includes('°') ? raw : `${raw}°F`;
            if (bucket && Number.isFinite(bucket.bucket_low_f) && Number.isFinite(bucket.bucket_high_f)) {
                return `${bucket.bucket_low_f}-${bucket.bucket_high_f}°F`;
            }
            return '--';
        }

        const parsed = parseBucketBoundsF(raw);
        if (parsed && parsed.kind === 'range') {
            const lowC = Math.round(fToC(parsed.low));
            const highC = Math.round(fToC(parsed.high));
            return lowC === highC ? `${lowC}°C` : `${lowC}-${highC}°C`;
        }
        if (parsed && parsed.kind === 'below') {
            return `${Math.round(fToC(parsed.threshold))}°C or below`;
        }
        if (parsed && parsed.kind === 'above') {
            return `${Math.round(fToC(parsed.threshold))}°C or higher`;
        }
        if (parsed && parsed.kind === 'single') {
            return `${Math.round(fToC(parsed.value))}°C`;
        }

        if (bucket && Number.isFinite(bucket.bucket_low_f) && Number.isFinite(bucket.bucket_high_f)) {
            const lowC = Math.round(fToC(bucket.bucket_low_f));
            const highC = Math.round(fToC(bucket.bucket_high_f));
            return lowC === highC ? `${lowC}°C` : `${lowC}-${highC}°C`;
        }
        if (raw) return raw.replace(/°F/gi, '°C');
        return '--';
    }

    function updateTimezoneFormatters() {
        const tz = stationTimezones[currentStation] || 'America/New_York';
        localTzLabel = TZ_LABELS[currentStation] || currentStation;

        localTimeFormatter = new Intl.DateTimeFormat('en-US', {
            timeZone: tz,
            hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false
        });
        localDateFormatter = new Intl.DateTimeFormat('en-US', {
            timeZone: tz,
            year: 'numeric', month: '2-digit', day: '2-digit'
        });
        localIsoDateFormatter = new Intl.DateTimeFormat('en-CA', {
            timeZone: tz,
            year: 'numeric', month: '2-digit', day: '2-digit'
        });
        esTimeFormatter = new Intl.DateTimeFormat('en-US', {
            timeZone: ES_TZ,
            hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false
        });

        // Update labels
        const timeLabel = document.getElementById('market-time-label');
        if (timeLabel) timeLabel.textContent = `Current Time ${localTzLabel} (ES)`;
        const peakLabel = document.getElementById('stat-peak-label');
        if (peakLabel) peakLabel.textContent = `Expected Peak ${localTzLabel} (ES)`;
        const dateLabel = document.getElementById('settlement-date-label');
        if (dateLabel) dateLabel.textContent = `Settlement Date (${localTzLabel})`;
        const tpeakTitle = document.getElementById('tpeak-title');
        if (tpeakTitle) tpeakTitle.textContent = `t_peak - Time of Maximum (${localTzLabel})`;
    }

    // Initialize
    async function init() {
        // Set up default formatters before anything else
        updateTimezoneFormatters();

        await loadStations();
        await loadNowcast();

        // Poll every 30 seconds
        pollInterval = setInterval(loadNowcast, 30000);

        // Update clock every second
        setInterval(updateMarketClock, 1000);
        updateMarketClock();
    }

    // Market clock and countdown
    function updateMarketClock() {
        if (!localTimeFormatter || !esTimeFormatter) return;
        const now = new Date();

        const localTime = localTimeFormatter.format(now);
        const esTime = esTimeFormatter.format(now);

        document.getElementById('market-time').textContent =
            `${localTime} ${localTzLabel} (${esTime} ES)`;

        // Parse local hour for countdown calculation
        const localHour = parseInt(localTime.split(':')[0]);
        const localMin = parseInt(localTime.split(':')[1]);
        const localSec = parseInt(localTime.split(':')[2]);

        // Market closes at midnight station local time
        const secondsUntilMidnight = (24 - localHour - 1) * 3600 + (60 - localMin - 1) * 60 + (60 - localSec);

        const countdownContainer = document.getElementById('market-countdown-container');

        if (secondsUntilMidnight > 0) {
            const hours = Math.floor(secondsUntilMidnight / 3600);
            const mins = Math.floor((secondsUntilMidnight % 3600) / 60);
            const secs = secondsUntilMidnight % 60;
            document.getElementById('market-countdown').textContent =
                `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            countdownContainer.style.display = 'flex';
        } else {
            countdownContainer.style.display = 'none';
        }
    }

    function updateMarketStatus(targetDate) {
        const now = new Date();
        const currentLocalDate = localIsoDateFormatter ? localIsoDateFormatter.format(now) : null;

        const badge = document.getElementById('market-status-badge');
        const countdownContainer = document.getElementById('market-countdown-container');

        // If already marked RESOLVED by checkMarketResolution (98%+ bracket),
        // don't override with date-based LIVE status
        if (badge.textContent === 'RESOLVED') return;

        // Compare against station local date.
        if (targetDate && currentLocalDate) {
            if (targetDate === currentLocalDate) {
                badge.className = 'market-status-badge live';
                badge.textContent = 'LIVE';
                countdownContainer.style.display = 'flex';
            } else if (targetDate < currentLocalDate) {
                badge.className = 'market-status-badge resolved';
                badge.textContent = 'RESOLVED';
                countdownContainer.style.display = 'none';
            } else {
                // Future market
                badge.className = 'market-status-badge';
                badge.style.background = 'rgba(59,130,246,0.2)';
                badge.style.color = '#3B82F6';
                badge.textContent = 'PENDING';
                countdownContainer.style.display = 'none';
            }
        }

        // Update the market date display with ES equivalent
        if (targetDate) {
            // Get current ES date for comparison
            const esDateFormatter = new Intl.DateTimeFormat('en-CA', {
                timeZone: 'Europe/Madrid',
                year: 'numeric',
                month: '2-digit',
                day: '2-digit'
            });
            const currentEsDate = esDateFormatter.format(now);

            // Format target date nicely
            const [year, month, day] = targetDate.split('-');
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                           'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const nycFormatted = `${parseInt(day)} ${months[parseInt(month)-1]} ${year}`;

            // Show ES date if it differs from NYC settlement date
            if (currentEsDate !== targetDate) {
                const [esYear, esMonth, esDay] = currentEsDate.split('-');
                const esFormatted = `${parseInt(esDay)} ${months[parseInt(esMonth)-1]}`;
                document.getElementById('market-date').innerHTML =
                    `${nycFormatted} <span style="color:var(--text-muted);font-size:12px;">(ES: ${esFormatted})</span>`;
            } else {
                document.getElementById('market-date').textContent = nycFormatted;
            }
        }
    }

    async function loadStations() {
        try {
            const resp = await fetch('/api/stations');
            const stations = await resp.json();
            if (!stations || stations.length === 0) return;

            // Store timezone info per station
            for (const stn of stations) {
                stationTimezones[stn.id] = stn.timezone;
                const unit = String(stn.market_unit || '').toUpperCase();
                if (unit === 'C' || unit === 'F') {
                    stationMarketUnits[stn.id] = unit;
                }
            }

            // If current station not in list, switch to first before rendering buttons
            if (!stations.find(s => s.id === currentStation) && stations.length > 0) {
                currentStation = stations[0].id;
            }

            const container = document.getElementById('station-selector');
            container.innerHTML = '';

            for (const stn of stations) {
                const btn = document.createElement('button');
                btn.className = 'station-btn' + (stn.id === currentStation ? ' active' : '');
                btn.textContent = stn.id;
                btn.onclick = () => selectStation(stn.id);
                container.appendChild(btn);
            }

            // Initialize formatters for the default station
            updateTimezoneFormatters();
        } catch (e) {
            console.error('Failed to load stations:', e);
        }
    }

    function selectStation(stationId) {
        currentStation = stationId;

        // Update buttons
        document.querySelectorAll('.station-btn').forEach(btn => {
            btn.classList.toggle('active', btn.textContent === stationId);
        });

        // Update timezone formatters for the new station
        updateTimezoneFormatters();
        loadNowcast();
    }

    async function loadNowcast() {
        try {
            // Fetch distribution, state, and market data in parallel
            const [distResp, stateResp, marketResp, metarResp] = await Promise.all([
                fetch(`/api/v3/nowcast/${currentStation}`),
                fetch(`/api/v3/nowcast/${currentStation}/state`),
                fetch(`/api/market/${currentStation}`),
                fetch(`/api/v2/world/metar_history/${currentStation}`)
            ]);

            const data = await distResp.json();
            const state = await stateResp.json();
            let marketData = null;
            try { marketData = await marketResp.json(); } catch {}
            let metarHistory = null;
            try { metarHistory = await metarResp.json(); } catch {}

            if (data.error) {
                console.warn('Nowcast error:', data.error);
                return;
            }

            renderNowcast(data, state, marketData, metarHistory);

            // Update timestamp in selected station local time
            let updateTime = new Date().toLocaleTimeString();
            if (data.ts_generated_utc) {
                try {
                    const d = new Date(data.ts_generated_utc);
                    if (!Number.isNaN(d.getTime()) && localTimeFormatter) {
                        updateTime = `${localTimeFormatter.format(d)} ${localTzLabel}`;
                    }
                } catch {}
            }
            document.getElementById('last-update').textContent = `Updated: ${updateTime}`;

        } catch (e) {
            console.error('Failed to load nowcast:', e);
        }
    }

    function renderNowcast(data, state, marketData, metarHistory) {
        // Check for market resolution via live Polymarket probabilities
        checkMarketResolution(marketData);

        // Update market status banner
        updateMarketStatus(data.target_date);

        // Central estimate
        const meanF = Number(data.tmax_mean_f);
        document.getElementById('tmax-mean').textContent =
            Number.isFinite(meanF) ? formatTempFromF(meanF, 1) : `--${tempUnitSymbol()}`;

        const sigmaF = Number(data.tmax_sigma_f);
        if (Number.isFinite(sigmaF)) {
            const sigmaDisplay = convertDeltaFromF(sigmaF);
            document.getElementById('tmax-sigma').textContent =
                `Uncertainty: ±${sigmaDisplay.toFixed(1)}${tempUnitSymbol()}`;
        } else {
            document.getElementById('tmax-sigma').textContent = 'Uncertainty: --';
        }

        // Max observed from state
        const maxObsF = state && state.max_so_far_f !== undefined && state.max_so_far_f > -900
            ? Number(state.max_so_far_f)
            : null;
        document.getElementById('stat-max-observed').textContent =
            maxObsF != null ? formatTempFromF(maxObsF, 0) : '--';

        // Confidence badge
        const badge = document.getElementById('confidence-badge');
        const conf = data.confidence || 0.5;
        badge.className = 'estimate-confidence ';
        if (conf >= 0.7) {
            badge.className += 'confidence-high';
            badge.textContent = `HIGH (${(conf * 100).toFixed(0)}%)`;
        } else if (conf >= 0.4) {
            badge.className += 'confidence-medium';
            badge.textContent = `MEDIUM (${(conf * 100).toFixed(0)}%)`;
        } else {
            badge.className += 'confidence-low';
            badge.textContent = `LOW (${(conf * 100).toFixed(0)}%)`;
        }

        // Stats
        const bias = data.bias_applied_f || 0;
        document.getElementById('stat-bias').textContent =
            formatSignedDeltaFromF(bias, 1);
        document.getElementById('stat-bias').className =
            'stat-value ' + (bias > 0 ? 'positive' : bias < 0 ? 'negative' : 'neutral');

        // Expected peak hour with both timezones
        if (data.t_peak_expected_hour !== undefined) {
            const peakLocal = data.t_peak_expected_hour;
            // Calculate ES hour dynamically from station tz offset
            const refDate = new Date();
            refDate.setHours(peakLocal, 0, 0, 0);
            // Compute offset: create a date at peak hour in station tz, format in ES tz
            const localStr = localTimeFormatter.format(refDate);
            const esStr = esTimeFormatter.format(refDate);
            const localH = parseInt(localStr.split(':')[0]);
            const esH = parseInt(esStr.split(':')[0]);
            const offset = ((esH - localH) + 24) % 24;
            const peakEs = (peakLocal + offset) % 24;
            document.getElementById('stat-peak-hour').textContent =
                `${peakLocal}:00 (${peakEs}:00)`;
        } else {
            document.getElementById('stat-peak-hour').textContent = '--';
        }

        document.getElementById('stat-base-source').textContent =
            data.base_forecast_source || '--';

        // Bucket probabilities
        renderBuckets(data.p_bucket || []);

        // Calculate current station-local hour for t_peak past-bin styling
        let currentLocalHour = new Date().getHours();
        if (data.ts_generated_utc && localTimeFormatter) {
            try {
                const d = new Date(data.ts_generated_utc);
                const timePart = localTimeFormatter.format(d);
                if (timePart) currentLocalHour = parseInt(timePart.split(':')[0], 10);
            } catch {}
        }

        renderTPeak(data.t_peak_bins || [], currentLocalHour);

        // Explanations
        renderExplanations(data.explanations || []);

        // Hourly temperature curve (base vs nowcast-adjusted vs observed)
        renderHourlyChart(data, metarHistory);
    }

    function checkMarketResolution(marketData) {
        const badge = document.getElementById('market-status-badge');
        const countdownContainer = document.getElementById('market-countdown-container');
        const estimateCard = document.querySelector('.estimate-card');

        // Remove any previous resolved overlay
        const oldOverlay = document.getElementById('resolved-overlay');
        if (oldOverlay) oldOverlay.remove();

        if (!marketData || marketData.error || !marketData.outcomes) return;

        // Find bracket with 98%+ probability = market resolved
        const winner = marketData.outcomes.find(o => o.probability >= 0.98);
        if (!winner) return;

        // Market is resolved!
        badge.className = 'market-status-badge resolved';
        badge.textContent = 'RESOLVED';
        countdownContainer.style.display = 'none';

        // Add resolved overlay to the estimate card
        const pct = (winner.probability * 100).toFixed(1);
        const overlay = document.createElement('div');
        overlay.id = 'resolved-overlay';
        overlay.style.cssText = `
            margin-top: 12px;
            padding: 10px 16px;
            background: rgba(16,185,129,0.15);
            border: 1px solid rgba(16,185,129,0.3);
            border-radius: 10px;
            text-align: center;
        `;
        overlay.innerHTML = `
            <div style="font-size:11px;text-transform:uppercase;letter-spacing:1px;color:#10B981;margin-bottom:4px;">
                Market Resolved
            </div>
            <div style="font-size:20px;font-weight:700;font-family:'JetBrains Mono',monospace;color:#10B981;">
                ${winner.title}
            </div>
            <div style="font-size:12px;color:var(--text-secondary);margin-top:4px;">
                ${pct}% probability
            </div>
        `;
        estimateCard.appendChild(overlay);
    }

    function renderBuckets(buckets) {
        const container = document.getElementById('bucket-container');
        container.innerHTML = '';

        const bucketSortValue = (label) => {
            const parsed = parseBucketBoundsF(label);
            if (!parsed) return -9999;
            if (parsed.kind === 'range') return Number(parsed.low);
            if (parsed.kind === 'single') return Number(parsed.value);
            if (parsed.kind === 'below' || parsed.kind === 'above') return Number(parsed.threshold);
            return -9999;
        };

        // Sort by bucket label (descending)
        buckets.sort((a, b) => {
            const aLow = bucketSortValue(a && a.label);
            const bLow = bucketSortValue(b && b.label);
            return bLow - aLow;
        });

        for (const bucket of buckets) {
            const prob = bucket.probability || 0;
            const pct = (prob * 100).toFixed(1);

            const row = document.createElement('div');
            row.className = 'bucket-row';
            row.innerHTML = `
                <div class="bucket-label">${formatBucketLabelForStation(bucket)}</div>
                <div class="bucket-bar-container">
                    <div class="bucket-bar ${bucket.is_impossible ? 'impossible' : ''}"
                         style="width: ${Math.max(prob * 100, 1)}%"></div>
                </div>
                <div class="bucket-prob">${pct}%</div>
            `;
            container.appendChild(row);
        }
    }

    function renderTPeak(bins, currentLocalHour) {
        const container = document.getElementById('tpeak-histogram');
        container.innerHTML = '';

        const maxProb = Math.max(...bins.map(b => b.probability || 0), 0.01);

        for (const bin of bins) {
            const prob = bin.probability || 0;
            const height = (prob / maxProb) * 100;
            const binStartHour = bin.bin_start_hour_nyc !== undefined ? bin.bin_start_hour_nyc : 0;
            const isPast = binStartHour < currentLocalHour;

            // Extract short labels (just the hours)
            const nycLabel = bin.label_short || bin.label_nyc || '--';
            const esLabel = bin.label_es ? bin.label_es.split('-')[0] : '';

            const wrapper = document.createElement('div');
            wrapper.className = 'tpeak-bar-wrapper';
            wrapper.innerHTML = `
                <div class="tpeak-bar ${isPast ? 'past' : ''}"
                     style="height: ${Math.max(height, 5)}%"
                     title="${bin.label || ''}"></div>
                <div class="tpeak-label">
                    <span class="tpeak-label-nyc">${nycLabel}</span><br>
                    <span class="tpeak-label-es">(${esLabel})</span>
                </div>
            `;
            container.appendChild(wrapper);
        }
    }

    function renderExplanations(explanations) {
        const container = document.getElementById('explanation-list');
        container.innerHTML = '';

        if (explanations.length === 0) {
            container.innerHTML = '<div style="color:var(--text-muted);font-size:13px;">No significant factors</div>';
            return;
        }

        for (const exp of explanations) {
            const item = document.createElement('div');
            item.className = 'explanation-item';

            const valueClass = exp.contribution_f > 0 ? 'positive' :
                              exp.contribution_f < 0 ? 'negative' : 'neutral';
            const valueText = exp.contribution_f !== 0 ?
                formatSignedDeltaFromF(exp.contribution_f, 1) : '';

            item.innerHTML = `
                <div class="explanation-factor">${exp.factor}</div>
                <div class="explanation-desc">${exp.description}</div>
                <div class="explanation-value ${valueClass}">${valueText}</div>
            `;
            container.appendChild(item);
        }
    }

    function renderHourlyChart(data, metarHistory) {
        const canvas = document.getElementById('hourly-chart');
        const meta = document.getElementById('hourly-meta');
        if (!canvas) return;

        if (hourlyChart) {
            hourlyChart.destroy();
            hourlyChart = null;
        }

        const unitSymbol = tempUnitSymbol();
        const toDisplayTemp = (tempF) => convertTempFromF(tempF);

        const base = Array.isArray(data?.base_hourly_f) ? data.base_hourly_f : [];
        const adjusted = Array.isArray(data?.nowcast_hourly_f) ? data.nowcast_hourly_f : [];

        if (!base.length && !adjusted.length) {
            if (meta) meta.textContent = 'No hourly base forecast available.';
            return;
        }

        const basePts = [];
        const adjPts = [];
        for (let h = 0; h < 24; h += 1) {
            const b = Number(base[h]);
            const a = Number(adjusted[h]);
            const bDisplay = Number.isFinite(b) ? toDisplayTemp(b) : null;
            const aDisplay = Number.isFinite(a) ? toDisplayTemp(a) : null;
            basePts.push({ x: h, y: Number.isFinite(bDisplay) ? bDisplay : null });
            adjPts.push({ x: h, y: Number.isFinite(aDisplay) ? aDisplay : null });
        }

        const obsPts = [];
        if (metarHistory && Array.isArray(metarHistory.observations)) {
            for (const r of metarHistory.observations) {
                const tF = Number(r?.temp_f_raw);
                const timeStr = String(r?.obs_time_local || '');
                const parts = timeStr.split(':');
                if (parts.length >= 2) {
                    const hh = parseInt(parts[0], 10);
                    const mm = parseInt(parts[1], 10);
                    const x = hh + (mm / 60.0);
                    const tDisplay = Number.isFinite(tF) ? toDisplayTemp(tF) : null;
                    if (Number.isFinite(x) && Number.isFinite(tDisplay)) obsPts.push({ x, y: tDisplay });
                }
            }
        }
        obsPts.sort((a, b) => a.x - b.x);

        const formatHour = (decimalHour) => {
            if (!Number.isFinite(decimalHour)) return '--:--';
            const totalMinutes = Math.max(0, Math.min((23 * 60) + 59, Math.round(decimalHour * 60)));
            const hh = Math.floor(totalMinutes / 60);
            const mm = totalMinutes % 60;
            return `${String(hh).padStart(2, '0')}:${String(mm).padStart(2, '0')}`;
        };

        const obsMax = (() => {
            let m = null;
            for (const p of obsPts) {
                if (m === null || p.y > m) m = p.y;
            }
            return m;
        })();

        const ctx = canvas.getContext('2d');
        hourlyChart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [
                    {
                        label: `Base (${data?.base_forecast_source || 'N/A'})`,
                        data: basePts,
                        borderColor: 'rgba(0, 212, 255, 0.70)',
                        backgroundColor: 'rgba(0, 212, 255, 0.08)',
                        tension: 0.25,
                        pointRadius: 0,
                        spanGaps: true,
                    },
                    {
                        label: 'Nowcast-adjusted',
                        data: adjPts,
                        borderColor: 'rgba(16, 185, 129, 0.80)',
                        backgroundColor: 'rgba(16, 185, 129, 0.08)',
                        tension: 0.25,
                        pointRadius: 0,
                        spanGaps: true,
                    },
                    {
                        label: 'NOAA METAR (obs time)',
                        data: obsPts,
                        borderColor: 'rgba(244, 208, 63, 0.95)',
                        backgroundColor: 'rgba(244, 208, 63, 0.95)',
                        borderWidth: 1.5,
                        tension: 0,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        pointStyle: 'rectRot',
                        fill: false,
                        spanGaps: false,
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'nearest',
                    axis: 'xy',
                    intersect: false,
                },
                hover: {
                    mode: 'nearest',
                    axis: 'xy',
                    intersect: false,
                },
                plugins: {
                    legend: {
                        labels: {
                            color: '#cbd5e1',
                            font: { size: 11 }
                        }
                    },
                    tooltip: {
                        position: 'nearest',
                        mode: 'nearest',
                        intersect: false,
                        callbacks: {
                            title: (items) => {
                                const xVal = Number(items?.[0]?.parsed?.x);
                                return Number.isFinite(xVal) ? `Hora ${formatHour(xVal)}` : '';
                            },
                            label: (ctx) => {
                                const datasetLabel = String(ctx?.dataset?.label || '');
                                const xVal = Number(ctx?.parsed?.x);
                                const yVal = Number(ctx?.parsed?.y);
                                const temp = Number.isFinite(yVal) ? `${yVal.toFixed(1)}${unitSymbol}` : '--';
                                if (datasetLabel === 'NOAA METAR (obs time)') {
                                    return `${datasetLabel}: ${temp} @ ${formatHour(xVal)}`;
                                }
                                return `${datasetLabel}: ${temp}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'linear',
                        min: 0,
                        max: 23,
                        ticks: {
                            stepSize: 2,
                            color: '#94a3b8',
                            callback: (v) => `${String(v).padStart(2, '0')}:00`,
                        },
                        grid: { color: 'rgba(255,255,255,0.05)' }
                    },
                    y: {
                        title: {
                            display: true,
                            text: unitSymbol,
                            color: '#94a3b8',
                        },
                        ticks: { color: '#94a3b8' },
                        grid: { color: 'rgba(255,255,255,0.05)' }
                    }
                }
            }
        });

        const bits = [];
        if (Number.isFinite(Number(data?.base_tmax_f))) {
            const h = Number.isFinite(Number(data?.base_peak_hour)) ? String(Number(data.base_peak_hour)).padStart(2, '0') : '--';
            const baseTmaxDisplay = toDisplayTemp(Number(data.base_tmax_f));
            if (Number.isFinite(baseTmaxDisplay)) {
                bits.push(`base tmax ${baseTmaxDisplay.toFixed(1)}${unitSymbol} @ ${h}:00`);
            }
        }
        if (Number.isFinite(Number(data?.tmax_mean_f))) {
            const nowcastDisplay = toDisplayTemp(Number(data.tmax_mean_f));
            if (Number.isFinite(nowcastDisplay)) bits.push(`nowcast tmax ${nowcastDisplay.toFixed(1)}${unitSymbol}`);
        }
        if (obsMax !== null) bits.push(`observed max ${obsMax.toFixed(1)}${unitSymbol}`);
        if (meta) meta.textContent = bits.length ? bits.join(' | ') : '--';
    }

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
        if (pollInterval) clearInterval(pollInterval);
    });

    // Start
    document.addEventListener('DOMContentLoaded', init);
    lucide.createIcons();
})();
</script>
{% endblock %}
