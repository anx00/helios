{% extends "base.html" %}

{% block title %}HELIOS - Replay{% endblock %}

{% block head_extra %}
<style>
    .replay-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 20px;
    }

    .mode-toggle {
        display: flex;
        background: rgba(255,255,255,0.05);
        border-radius: 8px;
        overflow: hidden;
    }

    .mode-btn {
        padding: 10px 24px;
        background: transparent;
        border: none;
        color: var(--text-secondary);
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
    }

    .mode-btn.active {
        background: var(--accent-blue);
        color: white;
    }

    .mode-btn:hover:not(.active) {
        background: rgba(255,255,255,0.1);
    }

    /* Session Selector */
    .session-selector {
        display: grid;
        grid-template-columns: 1fr 1fr auto;
        gap: 15px;
        background: var(--bg-secondary);
        border: 1px solid rgba(255,255,255,0.05);
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 20px;
    }

    .selector-group {
        display: flex;
        flex-direction: column;
        gap: 6px;
    }

    .selector-label {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--text-muted);
    }

    .selector-input {
        background: #1a1f2e;
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 8px;
        padding: 10px 14px;
        color: var(--text-main);
        font-size: 14px;
        font-family: 'JetBrains Mono', monospace;
        appearance: none;
        -webkit-appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%2394a3b8' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 12px center;
        padding-right: 32px;
        cursor: pointer;
    }

    .selector-input option {
        background: #1a1f2e;
        color: #e2e8f0;
        padding: 8px;
    }

    .selector-input:focus {
        outline: none;
        border-color: var(--accent-blue);
    }

    .load-btn {
        align-self: flex-end;
        padding: 10px 24px;
        background: var(--accent-blue);
        border: none;
        border-radius: 8px;
        color: white;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
    }

    .load-btn:hover {
        opacity: 0.9;
    }

    .load-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    /* Timeline Container */
    .timeline-container {
        background: var(--bg-secondary);
        border: 1px solid rgba(255,255,255,0.05);
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 20px;
    }

    .timeline-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 15px;
    }

    .timeline-time {
        font-family: 'JetBrains Mono', monospace;
        font-size: 24px;
        font-weight: 700;
        color: var(--text-main);
    }

    .timeline-time-label {
        font-size: 11px;
        color: var(--text-muted);
        margin-left: 10px;
    }

    .timeline-status {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .status-badge {
        padding: 4px 12px;
        border-radius: 20px;
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
    }

    .status-badge.idle { background: rgba(100,100,100,0.3); color: var(--text-muted); }
    .status-badge.loading { background: rgba(59,130,246,0.2); color: #3B82F6; }
    .status-badge.ready { background: rgba(16,185,129,0.2); color: #10B981; }
    .status-badge.playing { background: rgba(16,185,129,0.3); color: #10B981; }
    .status-badge.paused { background: rgba(244,208,63,0.2); color: #F4D03F; }
    .status-badge.finished { background: rgba(100,100,100,0.3); color: var(--text-muted); }

    /* Timeline Scrubber */
    .timeline-scrubber {
        position: relative;
        height: 40px;
        background: rgba(255,255,255,0.03);
        border-radius: 8px;
        margin-bottom: 15px;
        cursor: pointer;
    }

    .scrubber-progress {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        background: linear-gradient(90deg, rgba(0,120,255,0.3), rgba(0,212,255,0.2));
        border-radius: 8px;
    }

    .scrubber-progress.animated {
        transition: width 0.1s;
    }

    .scrubber-preview {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: 0;
        background: linear-gradient(90deg, rgba(16,185,129,0.26), rgba(34,211,238,0.18));
        border-radius: 8px;
        opacity: 0;
        transition: width 0.06s linear, opacity 0.12s ease;
        pointer-events: none;
    }

    .scrubber-preview.active {
        opacity: 1;
    }

    .scrubber-handle {
        position: absolute;
        top: 50%;
        width: 16px;
        height: 16px;
        background: var(--accent-blue);
        border: 2px solid white;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        cursor: grab;
        z-index: 10;
        transition: transform 0.1s;
    }

    .scrubber-handle:hover {
        transform: translate(-50%, -50%) scale(1.15);
    }

    .scrubber-handle.dragging {
        cursor: grabbing;
        transform: translate(-50%, -50%) scale(1.25);
    }

    .scrubber-markers {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 100%;
        pointer-events: none;
    }

    .scrubber-marker {
        position: absolute;
        top: 0;
        width: 2px;
        height: 100%;
        opacity: 0.7;
    }

    .scrubber-marker.metar { background: #10B981; }
    .scrubber-marker.window { background: #8B5CF6; }

    /* Playback Controls */
    .playback-controls {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 15px;
    }

    .control-btn {
        width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(255,255,255,0.05);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 50%;
        color: var(--text-secondary);
        cursor: pointer;
        transition: all 0.2s;
    }

    .control-btn:hover {
        background: rgba(255,255,255,0.1);
        color: var(--text-main);
    }

    .control-btn.primary {
        width: 56px;
        height: 56px;
        background: var(--accent-blue);
        border-color: var(--accent-blue);
        color: white;
    }

    .control-btn.primary:hover {
        opacity: 0.9;
    }

    .control-btn i {
        width: 20px;
        height: 20px;
    }

    /* Speed Selector */
    .speed-selector {
        display: flex;
        gap: 5px;
        margin-left: 20px;
    }

    .speed-btn {
        padding: 6px 12px;
        background: rgba(255,255,255,0.05);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 6px;
        color: var(--text-secondary);
        font-size: 12px;
        font-family: 'JetBrains Mono', monospace;
        cursor: pointer;
        transition: all 0.2s;
    }

    .speed-btn:hover {
        background: rgba(255,255,255,0.1);
    }

    .speed-btn.active {
        background: rgba(0,120,255,0.2);
        border-color: var(--accent-blue);
        color: var(--accent-blue);
    }

    /* Event Feed */
    .event-feed {
        background: var(--bg-secondary);
        border: 1px solid rgba(255,255,255,0.05);
        border-radius: 12px;
        overflow: hidden;
    }

    .feed-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 15px 20px;
        border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .feed-title {
        font-size: 14px;
        font-weight: 600;
        color: var(--text-main);
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .feed-title i {
        width: 16px;
        height: 16px;
        color: var(--accent-blue);
    }

    .feed-content {
        max-height: 400px;
        overflow-y: auto;
    }

    .event-item {
        display: flex;
        align-items: flex-start;
        gap: 12px;
        padding: 12px 20px;
        border-bottom: 1px solid rgba(255,255,255,0.03);
        transition: background 0.2s;
    }

    .event-item:hover {
        background: rgba(255,255,255,0.02);
    }

    .event-item.current {
        background: rgba(0,120,255,0.1);
        border-left: 3px solid var(--accent-blue);
    }

    .event-time {
        font-family: 'JetBrains Mono', monospace;
        font-size: 11px;
        color: var(--text-secondary);
        min-width: 100px;
        line-height: 1.5;
    }

    .event-channel {
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 10px;
        font-weight: 600;
        text-transform: uppercase;
        min-width: 60px;
        text-align: center;
    }

    .event-channel.world { background: rgba(16,185,129,0.2); color: #10B981; }
    .event-channel.nowcast { background: rgba(0,120,255,0.2); color: #0078FF; }
    .event-channel.pws { background: rgba(139,92,246,0.2); color: #8B5CF6; }
    .event-channel.features { background: rgba(244,208,63,0.2); color: #F4D03F; }
    .event-channel.health { background: rgba(100,100,100,0.3); color: var(--text-muted); }
    .event-channel.event_window { background: rgba(239,68,68,0.2); color: #EF4444; }
    .event-channel.market { background: rgba(249,115,22,0.2); color: #F97316; }
    .event-channel.l2_snap_1s { background: rgba(249,115,22,0.2); color: #F97316; }

    .event-content {
        flex: 1;
        font-size: 13px;
        color: var(--text-secondary);
    }

    .event-content strong {
        color: var(--text-main);
    }

    /* Stats Panel */
    .stats-row {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 15px;
        margin-bottom: 20px;
    }

    .stat-box {
        background: var(--bg-secondary);
        border: 1px solid rgba(255,255,255,0.05);
        border-radius: 10px;
        padding: 15px;
        text-align: center;
    }

    .stat-box-label {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: var(--text-muted);
        margin-bottom: 6px;
    }

    .stat-box-value {
        font-size: 24px;
        font-weight: 700;
        font-family: 'JetBrains Mono', monospace;
        color: var(--text-main);
    }

    /* Empty State */
    .empty-state {
        text-align: center;
        padding: 60px 20px;
        color: var(--text-muted);
    }

    .empty-state i {
        width: 48px;
        height: 48px;
        margin-bottom: 15px;
        opacity: 0.5;
    }

    /* Category Cards */
    .category-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 15px;
        margin-bottom: 20px;
    }

    .category-card {
        background: rgba(255, 255, 255, 0.02);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 12px;
        padding: 16px;
        transition: border-color 0.3s;
    }

    .category-card:hover {
        border-color: rgba(255, 255, 255, 0.12);
    }

    .category-card.empty {
        opacity: 0.45;
    }

    .category-card-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 10px;
    }

    .category-card-title {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 11px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .category-card-title i { width: 14px; height: 14px; }
    .category-card-title.world { color: #10B981; }
    .category-card-title.nowcast { color: #0078FF; }
    .category-card-title.pws { color: #8B5CF6; }
    .category-card-title.features { color: #F4D03F; }
    .category-card-title.event_window { color: #EF4444; }
    .category-card-title.health { color: var(--text-muted); }
    .category-card-title.l2_snap { color: #F97316; }

    /* Market Replay Panel */
    .market-replay-panel {
        background: rgba(255, 255, 255, 0.02);
        border: 1px solid rgba(249, 115, 22, 0.15);
        border-radius: 12px;
        padding: 18px;
        margin-bottom: 20px;
        display: none;
    }
    .market-replay-panel.visible { display: block; }
    .mr-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 14px;
    }
    .mr-title {
        font-size: 13px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1.5px;
        color: #F97316;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    .mr-title i { width: 14px; height: 14px; }
    .mr-time {
        font-size: 11px;
        color: var(--text-secondary);
    }
    .mr-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        gap: 10px;
    }
    .mr-empty {
        font-size: 12px;
        color: var(--text-muted);
        padding: 10px 2px;
    }
    .mr-bracket {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 10px;
        padding: 12px;
        transition: border-color 0.2s;
    }
    .mr-bracket.leading {
        border-color: rgba(249, 115, 22, 0.35);
        background: rgba(249, 115, 22, 0.05);
    }
    .mr-bracket-name {
        font-size: 12px;
        font-weight: 700;
        font-family: 'Space Grotesk', sans-serif;
        margin-bottom: 6px;
    }
    .mr-bracket-price {
        font-size: 20px;
        font-weight: 700;
        font-family: 'Space Grotesk', sans-serif;
        color: #F97316;
        margin-bottom: 6px;
    }
    .mr-bracket-book {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 10px;
        margin-bottom: 4px;
    }
    .mr-bid { color: #10B981; font-weight: 600; }
    .mr-spread { color: var(--text-secondary); }
    .mr-ask { color: #EF4444; font-weight: 600; }
    .mr-depth-bar {
        display: flex;
        height: 4px;
        border-radius: 2px;
        overflow: hidden;
        background: rgba(255, 255, 255, 0.04);
    }
    .mr-depth-bid { background: rgba(16, 185, 129, 0.45); }
    .mr-depth-ask { background: rgba(239, 68, 68, 0.45); }

    /* PWS Learning Replay Panel */
    .pws-learning-panel {
        background: rgba(255, 255, 255, 0.02);
        border: 1px solid rgba(139, 92, 246, 0.20);
        border-radius: 12px;
        padding: 18px;
        margin-bottom: 20px;
        display: none;
    }
    .pws-learning-panel.visible { display: block; }
    .pl-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
    }
    .pl-title {
        font-size: 13px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1.5px;
        color: #8B5CF6;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    .pl-title i { width: 14px; height: 14px; }
    .pl-meta {
        font-size: 11px;
        color: var(--text-muted);
        font-family: 'JetBrains Mono', monospace;
    }
    .pl-guide {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-bottom: 10px;
    }
    .pl-guide-pill {
        font-size: 10px;
        color: var(--text-secondary);
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(255, 255, 255, 0.03);
        border-radius: 999px;
        padding: 4px 8px;
    }
    .pl-guide-pill strong {
        color: var(--text-main);
        font-family: 'JetBrains Mono', monospace;
        font-size: 10px;
    }
    .pl-grid {
        display: grid;
        grid-template-columns: 1.2fr 1fr;
        gap: 12px;
    }
    .pl-card {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 10px;
        padding: 12px;
    }
    .pl-card-title {
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--text-muted);
        margin-bottom: 8px;
    }
    .pl-rank-item {
        padding: 4px 0 8px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.04);
    }
    .pl-rank-item:last-child {
        border-bottom: none;
        padding-bottom: 2px;
    }
    .pl-rank-row {
        display: grid;
        grid-template-columns: 28px 1fr auto auto auto;
        gap: 8px;
        align-items: center;
        font-size: 12px;
        padding: 4px 0;
    }
    .pl-rank-meta {
        font-size: 10px;
        color: var(--text-muted);
        margin: 2px 0 0 36px;
        line-height: 1.35;
    }
    .pl-rank-pos {
        color: var(--text-muted);
        font-family: 'JetBrains Mono', monospace;
    }
    .pl-rank-station {
        font-family: 'JetBrains Mono', monospace;
        color: var(--text-main);
        font-weight: 700;
    }
    .pl-pill {
        font-family: 'JetBrains Mono', monospace;
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.07);
        color: var(--text-secondary);
    }
    .pl-leader-strip {
        display: flex;
        gap: 2px;
        align-items: flex-end;
        height: 92px;
        margin-bottom: 8px;
    }
    .pl-leader-bar {
        flex: 1;
        min-width: 2px;
        border-radius: 2px 2px 0 0;
        background: rgba(139, 92, 246, 0.55);
    }
    .pl-strip-summary {
        font-size: 10px;
        color: var(--text-muted);
        margin-bottom: 8px;
        font-family: 'JetBrains Mono', monospace;
    }
    .pl-leader-events {
        max-height: 120px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 4px;
    }
    .pl-leader-event {
        font-size: 11px;
        color: var(--text-secondary);
        display: flex;
        justify-content: space-between;
        gap: 8px;
        border-bottom: 1px dotted rgba(255,255,255,0.08);
        padding-bottom: 3px;
    }
    .pl-empty {
        color: var(--text-muted);
        font-size: 12px;
    }
    .pl-consensus-card {
        margin-top: 12px;
    }
    .pl-consensus-summary {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 8px;
        margin-bottom: 10px;
    }
    .pl-cs-kpi {
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(255, 255, 255, 0.025);
        border-radius: 8px;
        padding: 8px 10px;
        min-height: 56px;
    }
    .pl-cs-kpi-label {
        display: block;
        font-size: 9px;
        text-transform: uppercase;
        letter-spacing: 0.7px;
        color: var(--text-muted);
        margin-bottom: 4px;
    }
    .pl-cs-kpi-value {
        display: block;
        font-size: 12px;
        color: var(--text-main);
        font-family: 'JetBrains Mono', monospace;
        font-weight: 600;
        line-height: 1.2;
    }
    .pl-cs-kpi-sub {
        display: block;
        font-size: 9px;
        color: var(--text-muted);
        margin-top: 3px;
        font-family: 'JetBrains Mono', monospace;
    }
    .pl-consensus-table-wrap {
        overflow-x: auto;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
    }
    .pl-consensus-table {
        width: 100%;
        min-width: 980px;
        border-collapse: collapse;
        font-size: 11px;
    }
    .pl-consensus-table thead th {
        position: sticky;
        top: 0;
        z-index: 1;
        text-align: left;
        padding: 7px 8px;
        color: var(--text-muted);
        background: rgba(10, 14, 28, 0.94);
        border-bottom: 1px solid rgba(255, 255, 255, 0.12);
        font-weight: 600;
        white-space: nowrap;
    }
    .pl-consensus-table tbody td {
        padding: 7px 8px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        color: var(--text-secondary);
        vertical-align: middle;
        white-space: nowrap;
    }
    .pl-consensus-table tbody tr:last-child td {
        border-bottom: none;
    }
    .pl-consensus-row-leader td {
        background: rgba(59, 130, 246, 0.10);
    }
    .pl-consensus-row-out td {
        opacity: 0.65;
    }
    .pl-cs-station {
        font-family: 'JetBrains Mono', monospace;
        font-weight: 700;
        color: var(--text-main);
    }
    .pl-cs-sub {
        display: block;
        font-size: 9px;
        color: var(--text-muted);
        margin-top: 2px;
    }
    .pl-cs-source {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 999px;
        font-size: 9px;
        font-weight: 700;
        letter-spacing: 0.4px;
    }
    .pl-cs-temp {
        color: var(--text-main);
        font-weight: 600;
    }
    .pl-cs-state {
        font-size: 10px;
        font-family: 'JetBrains Mono', monospace;
    }
    .pl-cs-state.in {
        color: #10B981;
    }
    .pl-cs-state.out {
        color: #F59E0B;
    }

    .replay-trend-panel {
        background: rgba(255, 255, 255, 0.02);
        border: 1px solid rgba(56, 189, 248, 0.20);
        border-radius: 12px;
        padding: 16px;
        margin-bottom: 20px;
        display: none;
    }
    .replay-trend-panel.visible {
        display: block;
    }
    .rt-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 10px;
        gap: 10px;
    }
    .rt-title {
        font-size: 12px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: #38BDF8;
        display: flex;
        align-items: center;
        gap: 7px;
    }
    .rt-title i {
        width: 14px;
        height: 14px;
    }
    .rt-meta {
        font-size: 10px;
        color: var(--text-muted);
        font-family: 'JetBrains Mono', monospace;
    }
    .rt-top3 {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-bottom: 10px;
    }
    .rt-pill {
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,0.10);
        background: rgba(255,255,255,0.03);
        padding: 4px 8px;
        font-size: 10px;
        color: var(--text-secondary);
        font-family: 'JetBrains Mono', monospace;
    }
    .rt-chart-wrap {
        height: 300px;
        width: 100%;
        border: 1px solid rgba(255,255,255,0.06);
        border-radius: 10px;
        padding: 8px;
        background: rgba(255,255,255,0.02);
    }

    @media (max-width: 1100px) {
        .mr-grid { grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); }
        .pl-grid { grid-template-columns: 1fr; }
    }

    .category-count {
        font-size: 11px;
        font-family: 'JetBrains Mono', monospace;
        color: var(--text-muted);
        background: rgba(255, 255, 255, 0.05);
        padding: 2px 8px;
        border-radius: 10px;
    }

    .category-card-body {
        font-size: 13px;
        color: var(--text-secondary);
        line-height: 1.5;
        min-height: 20px;
    }

    .category-card-body strong {
        color: var(--text-main);
    }

    .category-last-update {
        font-size: 10px;
        color: var(--text-muted);
        margin-top: 8px;
        font-family: 'JetBrains Mono', monospace;
    }

    @media (max-width: 1200px) {
        .session-selector {
            grid-template-columns: 1fr;
        }
        .stats-row {
            grid-template-columns: repeat(2, 1fr);
        }
        .category-grid {
            grid-template-columns: repeat(2, 1fr);
        }
    }

    @media (max-width: 768px) {
        .category-grid {
            grid-template-columns: 1fr;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="page-header">
    <div class="page-title">
        <i data-lucide="history" style="width:24px;height:24px;color:var(--accent-blue);"></i>
        Replay Center
    </div>
    <div class="mode-toggle">
        <a href="/nowcast" class="mode-btn">LIVE</a>
        <button class="mode-btn active">REPLAY</button>
    </div>
</div>

<div class="page-content">
    <!-- Session Selector -->
    <div class="session-selector">
        <div class="selector-group">
            <label class="selector-label">Date</label>
            <select id="date-select" class="selector-input">
                <option value="">Select a date...</option>
            </select>
        </div>
        <div class="selector-group" style="display:none;">
            <label class="selector-label">Station</label>
            <select id="station-select" class="selector-input">
                <option value="">All stations</option>
                {% for opt in station_selector_options %}
                <option value="{{ opt.id }}">{{ opt.label }}</option>
                {% endfor %}
            </select>
        </div>
        <button id="load-btn" class="load-btn" disabled>
            Load Session
        </button>
    </div>

    <!-- Timeline Container -->
    <div class="timeline-container" id="timeline-container" style="display: none;">
        <div class="timeline-header">
            <div>
                <span class="timeline-time" id="current-time">--:--:--</span>
                <span class="timeline-time-label" id="current-date">NYC</span>
            </div>
            <div class="timeline-status">
                <span class="status-badge idle" id="status-badge">IDLE</span>
            </div>
        </div>

        <!-- Scrubber -->
        <div class="timeline-scrubber" id="scrubber">
            <div class="scrubber-progress" id="scrubber-progress"></div>
            <div class="scrubber-preview" id="scrubber-preview"></div>
            <div class="scrubber-markers" id="scrubber-markers"></div>
            <div class="scrubber-handle" id="scrubber-handle"></div>
        </div>

        <!-- Playback Controls -->
        <div class="playback-controls">
            <button class="control-btn" id="btn-prev-metar" title="Previous METAR">
                <i data-lucide="skip-back"></i>
            </button>
            <button class="control-btn" id="btn-stop" title="Stop">
                <i data-lucide="square"></i>
            </button>
            <button class="control-btn primary" id="btn-play-pause" title="Play/Pause">
                <i data-lucide="play" id="play-icon"></i>
            </button>
            <button class="control-btn" id="btn-next-metar" title="Next METAR">
                <i data-lucide="skip-forward"></i>
            </button>
            <button class="control-btn" id="btn-next-window" title="Next Event Window">
                <i data-lucide="chevrons-right"></i>
            </button>

            <div class="speed-selector">
                <button class="speed-btn active" data-speed="1">1x</button>
                <button class="speed-btn" data-speed="2">2x</button>
                <button class="speed-btn" data-speed="5">5x</button>
                <button class="speed-btn" data-speed="10">10x</button>
                <button class="speed-btn" data-speed="50">50x</button>
            </div>
        </div>
    </div>

    <!-- Stats Row -->
    <div class="stats-row" id="stats-row" style="display: none;">
        <div class="stat-box">
            <div class="stat-box-label">Total Events</div>
            <div class="stat-box-value" id="stat-total">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-box-label">METARs</div>
            <div class="stat-box-value" id="stat-metars">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-box-label">Event Windows</div>
            <div class="stat-box-value" id="stat-windows">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-box-label">Progress</div>
            <div class="stat-box-value" id="stat-progress">0%</div>
        </div>
    </div>

    <!-- Category Cards -->
    <div class="category-grid" id="category-grid" style="display: none;">
        <div class="category-card empty" id="cat-world">
            <div class="category-card-header">
                <span class="category-card-title world">
                    <i data-lucide="radio-tower"></i> METAR
                </span>
                <span class="category-count" id="cat-world-count">0</span>
            </div>
            <div class="category-card-body" id="cat-world-body">No events yet</div>
            <div class="category-last-update" id="cat-world-time">--</div>
        </div>
        <div class="category-card empty" id="cat-nowcast">
            <div class="category-card-header">
                <span class="category-card-title nowcast">
                    <i data-lucide="cpu"></i> Nowcast
                </span>
                <span class="category-count" id="cat-nowcast-count">0</span>
            </div>
            <div class="category-card-body" id="cat-nowcast-body">No events yet</div>
            <div class="category-last-update" id="cat-nowcast-time">--</div>
        </div>
        <div class="category-card empty" id="cat-pws">
            <div class="category-card-header">
                <span class="category-card-title pws">
                    <i data-lucide="cloud-rain"></i> PWS
                </span>
                <span class="category-count" id="cat-pws-count">0</span>
            </div>
            <div class="category-card-body" id="cat-pws-body">No events yet</div>
            <div class="category-last-update" id="cat-pws-time">--</div>
        </div>
        <div class="category-card empty" id="cat-features">
            <div class="category-card-header">
                <span class="category-card-title features">
                    <i data-lucide="sliders-horizontal"></i> Features
                </span>
                <span class="category-count" id="cat-features-count">0</span>
            </div>
            <div class="category-card-body" id="cat-features-body">No events yet</div>
            <div class="category-last-update" id="cat-features-time">--</div>
        </div>
        <div class="category-card empty" id="cat-event_window">
            <div class="category-card-header">
                <span class="category-card-title event_window">
                    <i data-lucide="target"></i> Event Windows
                </span>
                <span class="category-count" id="cat-event_window-count">0</span>
            </div>
            <div class="category-card-body" id="cat-event_window-body">No events yet</div>
            <div class="category-last-update" id="cat-event_window-time">--</div>
        </div>
        <div class="category-card empty" id="cat-health">
            <div class="category-card-header">
                <span class="category-card-title health">
                    <i data-lucide="heart-pulse"></i> Health
                </span>
                <span class="category-count" id="cat-health-count">0</span>
            </div>
            <div class="category-card-body" id="cat-health-body">No events yet</div>
            <div class="category-last-update" id="cat-health-time">--</div>
        </div>
        <div class="category-card empty" id="cat-l2_snap">
            <div class="category-card-header">
                <span class="category-card-title l2_snap">
                    <i data-lucide="candlestick-chart"></i> Polymarket
                </span>
                <span class="category-count" id="cat-l2_snap-count">0</span>
            </div>
            <div class="category-card-body" id="cat-l2_snap-body">No events yet</div>
            <div class="category-last-update" id="cat-l2_snap-time">--</div>
        </div>
    </div>

    <!-- Market State Panel (from l2_snap replay data) -->
    <div class="market-replay-panel" id="market-replay-panel">
        <div class="mr-header">
            <span class="mr-title"><i data-lucide="candlestick-chart"></i> Market State</span>
            <span class="mr-time" id="mr-time">--</span>
        </div>
        <div class="mr-grid" id="mr-grid">
            <!-- Brackets populated by JS -->
        </div>
    </div>

    <div class="replay-trend-panel" id="replay-trend-panel">
        <div class="rt-header">
            <span class="rt-title"><i data-lucide="line-chart"></i> Replay Multi-Series (NOAA + PWS + Helios)</span>
            <span class="rt-meta" id="rt-meta">--</span>
        </div>
        <div class="rt-top3" id="rt-top3"></div>
        <div class="rt-chart-wrap">
            <canvas id="replay-trend-chart"></canvas>
        </div>
    </div>

    <!-- PWS Learning Replay Panel -->
    <div class="pws-learning-panel" id="pws-learning-panel">
        <div class="pl-header">
            <span class="pl-title"><i data-lucide="graduation-cap"></i> PWS Learning</span>
            <span class="pl-meta" id="pl-meta">--</span>
        </div>
        <div class="pl-guide" id="pl-guide"></div>
        <div class="pl-grid">
            <div class="pl-card">
                <div class="pl-card-title">Current Ranking (weight w)</div>
                <div id="pl-ranking" class="pl-empty">No data</div>
            </div>
            <div class="pl-card">
                <div class="pl-card-title">Leader Evolution (height=w, color=now/lead)</div>
                <div id="pl-strip" class="pl-leader-strip"></div>
                <div id="pl-strip-summary" class="pl-strip-summary">--</div>
                <div id="pl-events" class="pl-leader-events"></div>
            </div>
        </div>
        <div class="pl-card pl-consensus-card">
            <div class="pl-card-title">PWS Consensus Snapshot (temperatura por estacion + historico acumulado)</div>
            <div id="pl-consensus-summary" class="pl-consensus-summary"></div>
            <div id="pl-consensus-table" class="pl-consensus-table-wrap"></div>
        </div>
    </div>

    <!-- Combined Timeline -->
    <div class="event-feed" id="event-feed" style="display: none;">
        <div class="feed-header">
            <div class="feed-title">
                <i data-lucide="activity"></i>
                Combined Timeline
            </div>
        </div>
        <div class="feed-content" id="event-list">
            <!-- Events populated by JS -->
        </div>
    </div>

    <!-- Empty State -->
    <div class="empty-state" id="empty-state">
        <i data-lucide="database"></i>
        <h3>No Session Loaded</h3>
        <p>Select a date and click "Load Session" to begin replay.</p>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
(function() {
    let sessionId = null;
    let currentSpeed = 1;
    let isPlaying = false;
    let pollInterval = null;
    let isDragging = false;
    let sessionLoadedChannels = new Set();
    let currentReplayDate = '';
    let currentReplayStation = '';
    let updateInFlight = false;
    let queuedForceHeavy = false;
    let lastHeavyFetchAt = 0;
    let lastHeavyIndex = -1;
    let seekInFlight = false;
    let queuedSeekPercent = null;
    let wasPollingBeforeDrag = false;
    let replayTrendChart = null;
    let replayTrendZoomHandlersAttached = false;
    let replayTrendDragState = null;

    // Station timezone info (populated from template data)
    const stationTimezones = {
        {% for sid in active_stations %}
        '{{ sid }}': '{{ all_stations[sid].timezone }}',
        {% endfor %}
    };
    const stationMarketUnits = {
        {% for sid in active_stations %}
        '{{ sid }}': '{{ station_market_units.get(sid, "F") }}',
        {% endfor %}
    };
    const TZ_LABELS = {
        'KLGA': 'NYC',
        'KATL': 'ATL',
        'KORD': 'CHI',
        'KMIA': 'MIA',
        'KDAL': 'DAL',
        'LFPG': 'PAR',
        'EGLC': 'LON',
        'LTAC': 'ANK'
    };
    const ES_TZ = 'Europe/Madrid';

    // Dynamic timezone formatters (rebuilt when station changes)
    let localTimeFormatter = null;
    let localDateFormatter = null;
    let esTimeFormatter = null;
    let localTzLabel = '';

    function isReplayStationFilterVisible() {
        const select = document.getElementById('station-select');
        const group = select?.closest('.selector-group');
        if (!select || !group) return false;
        return window.getComputedStyle(group).display !== 'none';
    }

    function getReplayStationFilterValue() {
        if (!isReplayStationFilterVisible()) return '';
        return document.getElementById('station-select')?.value || '';
    }

    function currentStationId() {
        const selected = document.getElementById('station-select')?.value || '';
        const globalSelected = window.HeliosStationState?.get?.() || '';
        return (currentReplayStation || selected || globalSelected || 'KLGA').toUpperCase();
    }

    function getStationMarketUnit(stationId = currentStationId()) {
        const sid = String(stationId || '').toUpperCase();
        const raw = String(stationMarketUnits[sid] || '').toUpperCase();
        if (raw === 'C' || raw === 'CELSIUS') return 'C';
        if (raw === 'F' || raw === 'FAHRENHEIT') return 'F';
        return (sid === 'EGLC' || sid === 'LTAC' || sid === 'LFPG') ? 'C' : 'F';
    }

    function usesCelsius(stationId = currentStationId()) {
        return getStationMarketUnit(stationId) === 'C';
    }

    function tempUnitSymbol(stationId = currentStationId()) {
        return usesCelsius(stationId) ? ' C' : ' F';
    }

    function fToC(tempF) {
        return (Number(tempF) - 32) * (5 / 9);
    }

    function deltaFToC(deltaF) {
        return Number(deltaF) * (5 / 9);
    }

    function convertTempFromF(tempF, stationId = currentStationId()) {
        if (!Number.isFinite(Number(tempF))) return null;
        const value = Number(tempF);
        return usesCelsius(stationId) ? fToC(value) : value;
    }

    function convertDeltaFromF(deltaF, stationId = currentStationId()) {
        if (!Number.isFinite(Number(deltaF))) return null;
        const value = Number(deltaF);
        return usesCelsius(stationId) ? deltaFToC(value) : value;
    }

    function formatTempFromF(tempF, digits = 1, stationId = currentStationId()) {
        const converted = convertTempFromF(tempF, stationId);
        if (converted == null) return '--';
        return `${converted.toFixed(digits)}${tempUnitSymbol(stationId)}`;
    }

    function formatSignedDeltaFromF(deltaF, digits = 1, stationId = currentStationId()) {
        const converted = convertDeltaFromF(deltaF, stationId);
        if (converted == null) return '--';
        const sign = converted >= 0 ? '+' : '';
        return `${sign}${converted.toFixed(digits)}${tempUnitSymbol(stationId)}`;
    }

    function parseBucketBoundsF(label, stationId = currentStationId()) {
        if (!label) return null;
        const raw = String(label).trim();
        if (!raw) return null;

        const lower = raw.toLowerCase();

        const hasC = /\d\s*(?:\u00B0)?\s*c\b/i.test(raw) || /celsius/i.test(lower);
        const hasF = /\d\s*(?:\u00B0)?\s*f\b/i.test(raw) || /fahrenheit/i.test(lower);
        const defaultIsC = usesCelsius(stationId);
        const sourceIsC = hasC || (!hasF && defaultIsC);
        const toF = (v) => sourceIsC ? ((v * 9) / 5) + 32 : v;
        const numbers = raw.match(/-?\d+(?:\.\d+)?/g);
        if (!numbers || numbers.length === 0) return null;

        if (lower.includes('or below')) {
            const threshold = toF(Number(numbers[0]));
            return Number.isFinite(threshold) ? { kind: 'below', threshold } : null;
        }
        if (lower.includes('or above') || lower.includes('or higher')) {
            const threshold = toF(Number(numbers[0]));
            return Number.isFinite(threshold) ? { kind: 'above', threshold } : null;
        }
        const rangeMatch = raw.match(/(-?\d+(?:\.\d+)?)\s*[-â€“]\s*(-?\d+(?:\.\d+)?)/);
        if (rangeMatch) {
            const low = toF(Number(rangeMatch[1]));
            const high = toF(Number(rangeMatch[2]));
            if (Number.isFinite(low) && Number.isFinite(high)) {
                return { kind: 'range', low, high };
            }
        }

        const single = toF(Number(numbers[0]));
        if (Number.isFinite(single)) return { kind: 'single', value: single };
        return null;
    }

    function marketBracketMidpointF(label, stationId = currentStationId()) {
        const parsed = parseBucketBoundsF(label, stationId);
        if (!parsed) return null;
        if (parsed.kind === 'range') {
            const low = Number(parsed.low);
            const high = Number(parsed.high);
            if (Number.isFinite(low) && Number.isFinite(high)) {
                return (low + high) / 2;
            }
            return null;
        }
        if (parsed.kind === 'single') {
            const v = Number(parsed.value);
            return Number.isFinite(v) ? v : null;
        }
        if (parsed.kind === 'below' || parsed.kind === 'above') {
            const t = Number(parsed.threshold);
            return Number.isFinite(t) ? t : null;
        }
        return null;
    }

    function formatBucketLabelForStation(rawLabel, stationId = currentStationId()) {
        const parsed = parseBucketBoundsF(rawLabel, stationId);
        if (!parsed) return String(rawLabel || '--');

        if (usesCelsius(stationId)) {
            if (parsed.kind === 'range') {
                const lowC = Math.round(fToC(parsed.low));
                const highC = Math.round(fToC(parsed.high));
                const minC = Math.min(lowC, highC);
                const maxC = Math.max(lowC, highC);
                return minC === maxC ? `${minC} C` : `${minC}-${maxC} C`;
            }
            if (parsed.kind === 'below') return `${Math.round(fToC(parsed.threshold))} C or below`;
            if (parsed.kind === 'above') return `${Math.round(fToC(parsed.threshold))} C or higher`;
            if (parsed.kind === 'single') return `${Math.round(fToC(parsed.value))} C`;
            return String(rawLabel || '--');
        }

        if (parsed.kind === 'range') {
            const low = Math.round(parsed.low);
            const high = Math.round(parsed.high);
            const minF = Math.min(low, high);
            const maxF = Math.max(low, high);
            return minF === maxF ? `${minF} F` : `${minF}-${maxF} F`;
        }
        if (parsed.kind === 'below') return `${Math.round(parsed.threshold)} F or below`;
        if (parsed.kind === 'above') return `${Math.round(parsed.threshold)} F or higher`;
        if (parsed.kind === 'single') return `${Math.round(parsed.value)} F`;
        return String(rawLabel || '--');
    }
    function updateReplayFormatters() {
        const stationId = document.getElementById('station-select').value;
        const tz = stationTimezones[stationId] || 'America/New_York';
        localTzLabel = TZ_LABELS[stationId] || stationId || 'Local';

        localTimeFormatter = new Intl.DateTimeFormat('en-US', {
            timeZone: tz,
            hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false
        });
        localDateFormatter = new Intl.DateTimeFormat('en-CA', {
            timeZone: tz,
            year: 'numeric', month: '2-digit', day: '2-digit'
        });
        esTimeFormatter = new Intl.DateTimeFormat('en-US', {
            timeZone: ES_TZ,
            hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false
        });
    }

    function formatDualTime(isoUtc) {
        const dt = new Date(isoUtc);
        if (isNaN(dt.getTime())) return { local: '--:--:--', es: '--:--:--', date: '--' };
        return {
            local: localTimeFormatter.format(dt),
            es: esTimeFormatter.format(dt),
            date: localDateFormatter.format(dt)
        };
    }

    function localTimeFromTsNyc(tsNyc) {
        // ts_nyc format: "2026-02-07 15:30:00" - NYC time from recorder
        // Convert to station local time and ES time
        if (!tsNyc) return { local: '--:--', es: '--:--' };
        const timePart = tsNyc.split(' ')[1];
        if (!timePart) return { local: '--:--', es: '--:--' };
        const datePart = tsNyc.split(' ')[0];

        // ts_nyc is always NYC time from the recorder
        const nycFormatter = new Intl.DateTimeFormat('en-US', {
            timeZone: 'America/New_York',
            hour: '2-digit', minute: '2-digit', hour12: false
        });
        const nycShort = timePart.substring(0, 5);

        try {
            // Try EST/EDT offsets to reconstruct the UTC instant
            for (const offset of ['-05:00', '-04:00']) {
                const candidate = new Date(datePart + 'T' + timePart + offset);
                const nycRendered = nycFormatter.format(candidate).substring(0, 5);
                if (nycRendered === nycShort) {
                    return {
                        local: localTimeFormatter.format(candidate).substring(0, 5),
                        es: esTimeFormatter.format(candidate).substring(0, 5)
                    };
                }
            }
            // Fallback: EST
            const fallback = new Date(datePart + 'T' + timePart + '-05:00');
            return {
                local: localTimeFormatter.format(fallback).substring(0, 5),
                es: esTimeFormatter.format(fallback).substring(0, 5)
            };
        } catch {
            return { local: '--:--', es: '--:--' };
        }
    }

    // Initialize
    async function init() {
        const stationSelect = document.getElementById('station-select');
        const globalSelected = window.HeliosStationState?.get?.();
        if (
            isReplayStationFilterVisible() &&
            stationSelect &&
            globalSelected &&
            Array.from(stationSelect.options).some(o => o.value === globalSelected)
        ) {
            stationSelect.value = globalSelected;
        }
        updateReplayFormatters();  // Default formatters
        await loadAvailableDates();
        setupEventListeners();
        lucide.createIcons();
    }

    async function loadAvailableDates() {
        try {
            const station = getReplayStationFilterValue();
            const params = new URLSearchParams();
            if (station) params.append('station_id', station);
            const qs = params.toString();
            const resp = await fetch(`/api/v4/replay/dates${qs ? `?${qs}` : ''}`);
            const data = await resp.json();

            const select = document.getElementById('date-select');
            const prev = select.value;
            select.innerHTML = '<option value="">Select a date...</option>';

            for (const date of data.dates || []) {
                const opt = document.createElement('option');
                opt.value = date;
                opt.textContent = date;
                select.appendChild(opt);
            }
            if (prev && Array.from(select.options).some(o => o.value === prev)) {
                select.value = prev;
            }

            updateLoadButton();
        } catch (e) {
            console.error('Failed to load dates:', e);
        }
    }

    function setupEventListeners() {
        document.getElementById('date-select').onchange = updateLoadButton;
        document.getElementById('station-select').onchange = async () => {
            const station = getReplayStationFilterValue();
            if (station) {
                window.HeliosStationState?.set?.(station, { source: 'replay' });
            }
            updateReplayFormatters();
            await loadAvailableDates();
            updateLoadButton();
        };
        document.getElementById('load-btn').onclick = loadSession;
        document.getElementById('btn-play-pause').onclick = togglePlayPause;
        document.getElementById('btn-stop').onclick = stopSession;
        document.getElementById('btn-prev-metar').onclick = () => jump('prev_metar');
        document.getElementById('btn-next-metar').onclick = () => jump('next_metar');
        document.getElementById('btn-next-window').onclick = () => jump('next_window');

        // Speed buttons
        document.querySelectorAll('.speed-btn').forEach(btn => {
            btn.onclick = () => setSpeed(parseInt(btn.dataset.speed));
        });

        // Scrubber drag system
        const scrubber = document.getElementById('scrubber');
        const scrubberHandle = document.getElementById('scrubber-handle');
        const scrubberProgress = document.getElementById('scrubber-progress');
        const scrubberPreview = document.getElementById('scrubber-preview');

        function getScrubPercent(clientX) {
            const rect = scrubber.getBoundingClientRect();
            return Math.max(0, Math.min(100, ((clientX - rect.left) / rect.width) * 100));
        }

        function setPreviewPercent(pct) {
            if (!scrubberPreview) return;
            scrubberPreview.style.width = pct + '%';
        }

        function setPreviewActive(active) {
            if (!scrubberPreview) return;
            scrubberPreview.classList.toggle('active', Boolean(active));
        }

        function onDragStart(clientX) {
            isDragging = true;
            scrubberHandle.classList.add('dragging');
            scrubberProgress.classList.remove('animated');
            document.body.style.userSelect = 'none';
            wasPollingBeforeDrag = !!pollInterval;
            if (pollInterval) {
                clearInterval(pollInterval);
                pollInterval = null;
            }
            const pct = getScrubPercent(clientX);
            setPreviewPercent(pct);
            setPreviewActive(true);
            scrubberHandle.style.left = pct + '%';
        }

        function onDragMove(clientX) {
            if (!isDragging) return;
            const pct = getScrubPercent(clientX);
            setPreviewPercent(pct);
            scrubberHandle.style.left = pct + '%';
        }

        function onDragEnd(clientX) {
            if (!isDragging) return;
            isDragging = false;
            scrubberHandle.classList.remove('dragging');
            scrubberProgress.classList.add('animated');
            document.body.style.userSelect = '';
            const pct = getScrubPercent(clientX);
            setPreviewPercent(pct);
            seek(pct).finally(() => {
                setPreviewActive(false);
                if (wasPollingBeforeDrag && sessionId) {
                    adjustPollInterval();
                }
            });
        }

        scrubber.addEventListener('mousedown', (e) => {
            e.preventDefault();
            onDragStart(e.clientX);
        });
        document.addEventListener('mousemove', (e) => onDragMove(e.clientX));
        document.addEventListener('mouseup', (e) => onDragEnd(e.clientX));

        scrubber.addEventListener('touchstart', (e) => {
            e.preventDefault();
            onDragStart(e.touches[0].clientX);
        }, { passive: false });
        document.addEventListener('touchmove', (e) => {
            if (isDragging) { e.preventDefault(); onDragMove(e.touches[0].clientX); }
        }, { passive: false });
        document.addEventListener('touchend', (e) => {
            if (isDragging) onDragEnd(e.changedTouches[0].clientX);
        });
    }

    function updateLoadButton() {
        const date = document.getElementById('date-select').value;
        document.getElementById('load-btn').disabled = !date;
    }

    async function loadSession() {
        const date = document.getElementById('date-select').value;
        const station = getReplayStationFilterValue();

        if (!date) return;

        // Set timezone formatters based on selected station
        updateReplayFormatters();

        document.getElementById('load-btn').disabled = true;
        document.getElementById('load-btn').textContent = 'Loading...';

        try {
            const params = new URLSearchParams({ date });
            if (station) params.append('station_id', station);

            const resp = await fetch(`/api/v4/replay/session?${params}`, {
                method: 'POST'
            });
            const data = await resp.json();

            if (data.error) {
                let msg = data.error;
                if (data.available_dates && data.available_dates.length > 0) {
                    msg += `\n\nAvailable dates: ${data.available_dates.join(', ')}`;
                }
                if (data.channels_for_date && data.channels_for_date.length > 0) {
                    msg += `\nChannels on ${date}: ${data.channels_for_date.join(', ')}`;
                }
                alert(msg);
                return;
            }

            sessionId = data.session_id;
            showSession(data);

            // Start polling for state updates
            adjustPollInterval();

        } catch (e) {
            console.error('Failed to load session:', e);
            alert('Failed to load session');
        } finally {
            document.getElementById('load-btn').disabled = false;
            document.getElementById('load-btn').textContent = 'Load Session';
        }
    }

    function showSession(data) {
        document.getElementById('empty-state').style.display = 'none';
        document.getElementById('timeline-container').style.display = 'block';
        document.getElementById('stats-row').style.display = 'grid';
        document.getElementById('category-grid').style.display = 'grid';
        document.getElementById('event-feed').style.display = 'block';
        currentReplayDate = data.date || '';
        currentReplayStation = data.station_id || '';
        sessionLoadedChannels = new Set(Array.isArray(data.channels_loaded) ? data.channels_loaded : []);

        // Update stats
        document.getElementById('stat-total').textContent = data.total_events || 0;
        document.getElementById('stat-metars').textContent = data.metar_count || 0;
        document.getElementById('stat-windows').textContent = data.window_count || 0;

        updateState();
    }

    function pollIntervalMsForSpeed(speed) {
        const s = Number(speed) || 1;
        if (s >= 50) return 260;
        if (s >= 10) return 250;
        if (s >= 5) return 280;
        if (s >= 2) return 320;
        return 420;
    }

    function heavyRefreshMsForSpeed(speed) {
        const s = Number(speed) || 1;
        if (s >= 50) return 1400;
        if (s >= 10) return 900;
        if (s >= 5) return 700;
        if (s >= 2) return 500;
        return 260;
    }

    async function updateState(forceHeavy = false) {
        if (!sessionId) return;
        if (updateInFlight) {
            queuedForceHeavy = queuedForceHeavy || Boolean(forceHeavy);
            return;
        }

        updateInFlight = true;

        try {
            const resp = await fetch(`/api/v4/replay/session/${sessionId}/state`);
            const data = await resp.json();
            sessionLoadedChannels = new Set(Array.isArray(data.channels_loaded) ? data.channels_loaded : []);
            currentReplayDate = data.date || currentReplayDate;
            currentReplayStation = data.station_id || currentReplayStation;

            // Update status badge
            const badge = document.getElementById('status-badge');
            badge.className = `status-badge ${data.state}`;
            badge.textContent = data.state.toUpperCase();

            isPlaying = data.state === 'playing';
            updatePlayButton();

            // Update clock with dual timezone (station local + Spain)
            if (data.clock) {
                const currentTime = data.clock.current_time;
                if (currentTime) {
                    const tz = formatDualTime(currentTime);
                    document.getElementById('current-time').textContent =
                        `${tz.local} ${localTzLabel}`;
                    document.getElementById('current-date').textContent =
                        `${tz.es} ES | ${tz.date}`;
                }

                // Update progress (skip visual update during drag)
                const progress = data.clock.progress_percent || 0;
                document.getElementById('stat-progress').textContent =
                    progress.toFixed(1) + '%';
                if (!isDragging) {
                    document.getElementById('scrubber-progress').style.width =
                        progress + '%';
                    const previewEl = document.getElementById('scrubber-preview');
                    if (previewEl) {
                        previewEl.style.width = progress + '%';
                        previewEl.classList.remove('active');
                    }
                    document.getElementById('scrubber-handle').style.left =
                        progress + '%';
                }
            }

            const nowMs = Date.now();
            const currentIndex = Number(data.current_index || 0);
            const heavyAgeMs = nowMs - lastHeavyFetchAt;
            const heavyGapIndex = Math.abs(currentIndex - lastHeavyIndex);
            const heavyByTime = heavyAgeMs >= heavyRefreshMsForSpeed(currentSpeed);
            const heavyByIndex = lastHeavyIndex < 0 || (isPlaying ? heavyGapIndex >= 40 : heavyGapIndex >= 1);
            const heavyNeeded = Boolean(
                forceHeavy || (
                    !isDragging && (
                        (isPlaying && (heavyByTime || heavyByIndex)) ||
                        (!isPlaying && heavyByIndex)
                    )
                )
            );
            if (!heavyNeeded) {
                return;
            }

            // Get events, categories and PWS learning in parallel (throttled).
            const [eventsResp, catResp, pwsLearnResp] = await Promise.all([
                fetch(`/api/v4/replay/session/${sessionId}/events?n=10`),
                fetch(`/api/v4/replay/session/${sessionId}/categories`),
                fetch(`/api/v4/replay/session/${sessionId}/pws_learning?max_points=96&top_n=6&trend_points=320&trend_mode=5min`)
            ]);
            const eventsData = await eventsResp.json();
            const catData = await catResp.json();
            const pwsLearnData = await pwsLearnResp.json();
            renderEvents(eventsData);
            renderCategories(catData);
            renderPwsLearning(pwsLearnData, catData);
            lastHeavyFetchAt = nowMs;
            lastHeavyIndex = currentIndex;

        } catch (e) {
            console.error('State update error:', e);
        } finally {
            updateInFlight = false;
            if (queuedForceHeavy) {
                const runForced = queuedForceHeavy;
                queuedForceHeavy = false;
                setTimeout(() => updateState(runForced), 0);
            }
        }
    }

    function renderEvents(data) {
        const container = document.getElementById('event-list');
        const events = [
            ...(data.before || []),
            data.current ? { ...data.current, isCurrent: true } : null,
            ...(data.after || [])
        ].filter(Boolean);

        container.innerHTML = events.map(e => {
            const ch = e.ch || 'unknown';
            const tz = localTimeFromTsNyc(e.ts_nyc);
            const content = formatEventContent(e);

            return `
                <div class="event-item ${e.isCurrent ? 'current' : ''}">
                    <span class="event-time">${tz.local} <span style="color:var(--text-muted);font-size:9px;">${localTzLabel}</span><br>${tz.es} <span style="color:var(--text-muted);font-size:9px;">ES</span></span>
                    <span class="event-channel ${ch}">${ch}</span>
                    <span class="event-content">${content}</span>
                </div>
            `;
        }).join('');
    }

    // Station-unit-aware formatter (F for US markets, C for C markets).
    function formatEventContent(event) {
        const data = event.data || {};
        const ch = event.ch;
        const stationId = String(event.station_id || currentStationId()).toUpperCase();

        if (ch === 'world') {
            const tempText = formatTempFromF(data.temp_f, 1, stationId);
            const alignedText = formatTempFromF(data.temp_aligned, 1, stationId);
            return `<strong>${data.src || 'OBS'}</strong>: ${tempText} (aligned: ${alignedText})`;
        }
        if (ch === 'nowcast') {
            const meanText = formatTempFromF(data.tmax_mean_f, 1, stationId);
            const sigmaText = formatSignedDeltaFromF(data.tmax_sigma_f, 1, stationId).replace(/^\+/, '');
            return `Tmax: <strong>${meanText}</strong> +/- ${sigmaText}, conf: ${(data.confidence * 100).toFixed(0)}%`;
        }
        if (ch === 'pws') {
            const weightedSupport = Number(data.weighted_support);
            const wsText = Number.isFinite(weightedSupport)
                ? `, w-support: ${weightedSupport.toFixed(2)}`
                : '';

            let topText = '';
            const learning = data.station_learning || {};
            const rows = Object.values(learning).filter(v => v && typeof v === 'object');
            if (rows.length > 0) {
                const eligible = rows
                    .filter(isRankEligible)
                    .sort((a, b) => Number(b.weight || 0) - Number(a.weight || 0));
                const top = eligible.length > 0 ? eligible[0] : null;
                if (top && top.station_id) {
                    const w = numericOrNaN(top.weight);
                    const now = numericOrNaN(top.now_score);
                    const lead = numericOrNaN(top.lead_score);
                    const wStr = Number.isFinite(w) ? w.toFixed(2) : '--';
                    const nowStr = Number.isFinite(now) ? now.toFixed(0) : '--';
                    const leadStr = Number.isFinite(lead) ? lead.toFixed(0) : '--';
                    topText = ` | top: <strong>${top.station_id}</strong> w=${wStr} now=${nowStr} lead=${leadStr}`;
                } else {
                    topText = ' | learning: warm-up';
                }
            }

            const medianText = formatTempFromF(data.median_f, 1, stationId);
            return `PWS consensus: <strong>${medianText}</strong>, support: ${data.support || 0}${wsText}${topText}`;
        }
        if (ch === 'event_window') {
            return `<strong>${data.action}</strong>: ${data.reason}`;
        }
        if (ch === 'features') {
            const env = data.features?.env || {};
            const stale = data.staleness || {};
            const parts = [];
            for (const [k, feat] of Object.entries(env)) {
                if (!feat || typeof feat !== 'object') continue;
                const val = feat.value;
                const unit = feat.unit || '';
                const status = feat.status || '';
                if (val !== null && val !== undefined) {
                    const statusCls = status === 'OK' ? '' : ` (${status})`;
                    parts.push(`${feat.feature_type || k}: <strong>${typeof val === 'number' ? val.toFixed(1) : val}${unit}</strong>${statusCls}`);
                }
            }
            const staleEntries = Object.entries(stale).filter(([,v]) => v !== null);
            const maxStale = staleEntries.length > 0
                ? Math.max(...staleEntries.map(([,v]) => v))
                : null;
            const staleStr = maxStale !== null ? ` | max age: ${Math.floor(maxStale / 60)}m${Math.floor(maxStale % 60)}s` : '';
            return (parts.length > 0 ? parts.join(', ') : 'Features updated') + staleStr;
        }
        if (ch === 'health') {
            const src = data.sources || {};
            const ok = Object.values(src).filter(v => v === 'OK').length;
            const total = Object.keys(src).length;
            const reconn = data.reconnects || 0;
            const gaps = data.gaps || 0;
            return `Sources: <strong>${ok}/${total} OK</strong> | Reconnects: ${reconn} | Gaps: ${gaps}`;
        }
        if (ch === 'l2_snap' || ch === 'market' || ch === 'l2_snap_1s') {
            const brackets = Object.entries(data)
                .filter(([k]) => k !== '__meta__')
                .map(([name, b]) => ({ name: formatBucketLabelForStation(name, stationId), mid: b.mid || 0 }))
                .sort((a, b) => b.mid - a.mid)
                .slice(0, 3);
            if (brackets.length === 0) return 'No brackets';
            return brackets.map(b =>
                `<strong>${b.name}</strong> ${(b.mid * 100).toFixed(1)}c`
            ).join(' | ');
        }

        return JSON.stringify(data).substring(0, 100);
    }

    function renderCategories(categories) {
        for (const [ch, info] of Object.entries(categories)) {
            const countEl = document.getElementById(`cat-${ch}-count`);
            const bodyEl = document.getElementById(`cat-${ch}-body`);
            const timeEl = document.getElementById(`cat-${ch}-time`);
            const cardEl = document.getElementById(`cat-${ch}`);

            if (!countEl) continue;

            countEl.textContent = info.count;

            if (info.latest && info.count > 0) {
                bodyEl.innerHTML = formatEventContent(info.latest);
                timeEl.textContent = info.latest_time || '--';
                cardEl.classList.remove('empty');
            } else {
                bodyEl.textContent = 'No events yet';
                timeEl.textContent = '--';
                cardEl.classList.add('empty');
            }
        }

        // Update Market State panel from l2_snap data
        const l2 = categories.l2_snap;
        if (l2 && l2.latest && l2.count > 0) {
            renderMarketPanel(l2.latest.data, l2.latest_time, undefined, l2.latest.station_id);
        } else {
            const hasAnyL2Channel =
                sessionLoadedChannels.has('l2_snap') ||
                sessionLoadedChannels.has('market') ||
                sessionLoadedChannels.has('l2_snap_1s');
            const stationLabel = currentReplayStation || document.getElementById('station-select')?.value || 'ALL';
            const reason = hasAnyL2Channel
                ? 'No market snapshot yet at this replay timestamp.'
                : `No Polymarket snapshots recorded for ${stationLabel} on ${currentReplayDate || 'this date'}.`;
            renderMarketPanel(null, null, reason, currentReplayStation);
        }

        lucide.createIcons();
    }

    function scoreColor(score) {
        const s = numericOrNaN(score);
        if (!Number.isFinite(s)) return 'var(--text-muted)';
        if (s >= 85) return '#10B981';
        if (s >= 70) return '#22C55E';
        if (s >= 55) return '#F4D03F';
        if (s >= 40) return '#F97316';
        return '#EF4444';
    }

    function numericOrNaN(value) {
        if (value === null || value === undefined || value === '') return NaN;
        const n = Number(value);
        return Number.isFinite(n) ? n : NaN;
    }

    function isRankEligible(row) {
        if (!row || typeof row !== 'object') return false;
        if (typeof row.rank_eligible === 'boolean') return row.rank_eligible;
        const nowSamples = numericOrNaN(row.now_samples);
        const leadSamples = numericOrNaN(row.lead_samples);
        const minNow = Number.isFinite(numericOrNaN(row.rank_min_now_samples)) ? Number(row.rank_min_now_samples) : 2;
        const minLead = Number.isFinite(numericOrNaN(row.rank_min_lead_samples)) ? Number(row.rank_min_lead_samples) : 1;
        return nowSamples >= minNow && leadSamples >= minLead;
    }

    function escapeHtml(value) {
        return String(value ?? '')
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    }

    function normalizeSourceName(source) {
        return String(source || 'UNKNOWN').toUpperCase();
    }

    function pwsSourceBadge(source) {
        const src = normalizeSourceName(source);
        if (src === 'SYNOPTIC') return { label: 'SYN', color: '#10B981', title: 'Synoptic' };
        if (src === 'OPEN_METEO') return { label: 'OM', color: '#F59E0B', title: 'Open-Meteo' };
        if (src === 'WUNDERGROUND') return { label: 'WU', color: '#F97316', title: 'Wunderground' };
        if (src.startsWith('MADIS_APRSWXNET')) return { label: 'CWOP', color: '#22C55E', title: 'MADIS APRSWXNET' };
        if (src.startsWith('MADIS_')) return { label: 'MADIS', color: '#06B6D4', title: src };
        return { label: src.slice(0, 8) || 'UNK', color: '#6B7280', title: src || 'UNKNOWN' };
    }

    function formatAgeMinutes(ageMinutes) {
        const n = numericOrNaN(ageMinutes);
        if (!Number.isFinite(n)) return '--';
        if (n < 60) return `${n.toFixed(0)}m`;
        const h = Math.floor(n / 60);
        const m = Math.round(n % 60);
        return `${h}h ${m}m`;
    }

    function formatObsLocal(isoUtc) {
        if (!isoUtc || !localTimeFormatter || !esTimeFormatter) return '--';
        const dt = new Date(isoUtc);
        if (Number.isNaN(dt.getTime())) return '--';
        return `${localTimeFormatter.format(dt)} ${localTzLabel} | ${esTimeFormatter.format(dt)} ES`;
    }

    function renderPwsConsensusSnapshot(snapshot, opts = {}) {
        const summaryEl = opts.summaryEl;
        const tableEl = opts.tableEl;
        const stationId = String(opts.stationId || currentStationId()).toUpperCase();
        const metarTempF = numericOrNaN(opts.metarTempF);
        const fallbackLeader = String(opts.leaderStationId || '').toUpperCase();
        const pwsTickLabel = String(opts.pwsTickLabel || '--');
        const pwsTickNyc = String(opts.pwsTickNyc || '--');

        if (!summaryEl || !tableEl) return;
        if (!snapshot || typeof snapshot !== 'object') {
            summaryEl.innerHTML = '<div class="pl-empty">No consensus snapshot</div>';
            tableEl.innerHTML = '';
            return;
        }

        const rows = Array.isArray(snapshot.rows) ? snapshot.rows.slice() : [];
        if (rows.length === 0) {
            summaryEl.innerHTML = '<div class="pl-empty">No station-level rows in this replay tick.</div>';
            tableEl.innerHTML = '';
            return;
        }

        const leaderStationId = String(snapshot.leader_station_id || fallbackLeader || '').toUpperCase();
        rows.sort((a, b) => {
            const aIn = a && a.in_consensus === true ? 0 : 1;
            const bIn = b && b.in_consensus === true ? 0 : 1;
            if (aIn !== bIn) return aIn - bIn;
            const aLeader = String(a && a.station_id || '').toUpperCase() === leaderStationId ? 0 : 1;
            const bLeader = String(b && b.station_id || '').toUpperCase() === leaderStationId ? 0 : 1;
            if (aLeader !== bLeader) return aLeader - bLeader;
            const aW = Number.isFinite(numericOrNaN(a && a.weight)) ? Number(a.weight) : -1;
            const bW = Number.isFinite(numericOrNaN(b && b.weight)) ? Number(b.weight) : -1;
            if (aW !== bW) return bW - aW;
            return String(a && a.station_id || '').localeCompare(String(b && b.station_id || ''));
        });

        const histRows = rows
            .map(row => ({
                row,
                score: numericOrNaN(row && row.predictive_score),
                samples: numericOrNaN(row && row.samples_total),
            }))
            .filter(x => Number.isFinite(x.score))
            .sort((a, b) => (b.score - a.score) || ((Number.isFinite(b.samples) ? b.samples : -1) - (Number.isFinite(a.samples) ? a.samples : -1)));
        const histTop = histRows.length > 0 ? histRows[0].row : null;

        const inConsensusCount = Number.isFinite(numericOrNaN(snapshot.in_consensus_count))
            ? Number(snapshot.in_consensus_count)
            : rows.filter(r => r && r.in_consensus === true).length;
        const excludedCount = Number.isFinite(numericOrNaN(snapshot.excluded_count))
            ? Number(snapshot.excluded_count)
            : Math.max(0, rows.length - inConsensusCount);
        const weightedSupport = numericOrNaN(snapshot.weighted_support);
        const support = numericOrNaN(snapshot.support);
        const histScore = histTop ? numericOrNaN(histTop.predictive_score) : NaN;
        const histSamples = histTop ? numericOrNaN(histTop.samples_total) : NaN;
        const histId = histTop ? String(histTop.station_id || '--') : '--';
        const leaderRow = rows.find(r => String(r && r.station_id || '').toUpperCase() === leaderStationId) || null;
        const leaderWeight = numericOrNaN(leaderRow && leaderRow.weight);

        summaryEl.innerHTML = [
            `<div class="pl-cs-kpi"><span class="pl-cs-kpi-label">PWS Tick</span><span class="pl-cs-kpi-value">${escapeHtml(pwsTickLabel)}</span><span class="pl-cs-kpi-sub">${escapeHtml(pwsTickNyc)} NYC</span></div>`,
            `<div class="pl-cs-kpi"><span class="pl-cs-kpi-label">Stations</span><span class="pl-cs-kpi-value">${inConsensusCount} IN / ${excludedCount} OUT</span><span class="pl-cs-kpi-sub">support ${Number.isFinite(support) ? support : '--'} | w-support ${Number.isFinite(weightedSupport) ? weightedSupport.toFixed(2) : '--'}</span></div>`,
            `<div class="pl-cs-kpi"><span class="pl-cs-kpi-label">Leader (w actual)</span><span class="pl-cs-kpi-value">${escapeHtml(leaderStationId || '--')}</span><span class="pl-cs-kpi-sub">w ${Number.isFinite(leaderWeight) ? leaderWeight.toFixed(2) : '--'}</span></div>`,
            `<div class="pl-cs-kpi"><span class="pl-cs-kpi-label">Top Historico</span><span class="pl-cs-kpi-value">${escapeHtml(histId)}</span><span class="pl-cs-kpi-sub">hist ${Number.isFinite(histScore) ? histScore.toFixed(0) : '--'} | N ${Number.isFinite(histSamples) ? histSamples : '--'} (H)</span></div>`,
        ].join('');

        tableEl.innerHTML = `
            <table class="pl-consensus-table">
                <thead>
                    <tr>
                        <th>Station</th>
                        <th>Src</th>
                        <th>Temp</th>
                        <th>vs METAR</th>
                        <th>w</th>
                        <th>Hist</th>
                        <th>Now</th>
                        <th>Lead</th>
                        <th>N now (H)</th>
                        <th>N lead (H)</th>
                        <th>Age</th>
                        <th>State</th>
                    </tr>
                </thead>
                <tbody>
                    ${rows.map((row) => {
                        const sid = String(row && row.station_id || '--').toUpperCase();
                        const stationName = String(row && row.station_name || '');
                        const source = pwsSourceBadge(row && row.source);
                        const tempF = Number.isFinite(numericOrNaN(row && row.temp_f))
                            ? Number(row.temp_f)
                            : (Number.isFinite(numericOrNaN(row && row.temp_c)) ? ((Number(row.temp_c) * 9.0 / 5.0) + 32.0) : NaN);
                        const tempText = Number.isFinite(tempF) ? formatTempFromF(tempF, 1, stationId) : '--';
                        const tempAlt = Number.isFinite(tempF)
                            ? (usesCelsius(stationId) ? `${tempF.toFixed(1)} F` : `${fToC(tempF).toFixed(1)} C`)
                            : '--';
                        const deltaF = (Number.isFinite(tempF) && Number.isFinite(metarTempF)) ? (tempF - metarTempF) : NaN;
                        const deltaText = formatSignedDeltaFromF(deltaF, 1, stationId);
                        const deltaConverted = convertDeltaFromF(deltaF, stationId);
                        let deltaColor = 'var(--text-muted)';
                        if (Number.isFinite(deltaConverted)) {
                            const absDelta = Math.abs(deltaConverted);
                            if (absDelta <= 0.3) deltaColor = '#10B981';
                            else if (absDelta <= 0.8) deltaColor = '#F4D03F';
                            else deltaColor = '#EF4444';
                        }
                        const weight = numericOrNaN(row && row.weight);
                        const hist = numericOrNaN(row && row.predictive_score);
                        const now = numericOrNaN(row && row.now_score);
                        const lead = numericOrNaN(row && row.lead_score);
                        const nNow = numericOrNaN(row && row.now_samples);
                        const nLead = numericOrNaN(row && row.lead_samples);
                        const nNowSession = numericOrNaN(row && row.now_samples_session);
                        const nLeadSession = numericOrNaN(row && row.lead_samples_session);
                        const ageText = formatAgeMinutes(row && row.age_minutes);
                        const obsText = formatObsLocal(row && row.obs_time_utc);
                        const inConsensus = row && row.in_consensus === true;
                        const isLeader = sid === leaderStationId;
                        const stateRaw = inConsensus
                            ? 'IN'
                            : `OUT${row && row.excluded_reason ? ` (${String(row.excluded_reason)})` : ''}`;
                        const stateCls = inConsensus ? 'in' : 'out';
                        const rowClass = `${isLeader ? ' pl-consensus-row-leader' : ''}${!inConsensus ? ' pl-consensus-row-out' : ''}`;

                        return `
                            <tr class="${rowClass}">
                                <td>
                                    <span class="pl-cs-station">${escapeHtml(sid)}</span>
                                    <span class="pl-cs-sub">${escapeHtml(stationName || '--')}</span>
                                </td>
                                <td>
                                    <span class="pl-cs-source" style="background:${source.color}22;color:${source.color};" title="${escapeHtml(source.title)}">${escapeHtml(source.label)}</span>
                                </td>
                                <td>
                                    <span class="pl-cs-temp">${escapeHtml(tempText)}</span>
                                    <span class="pl-cs-sub">${escapeHtml(tempAlt)}</span>
                                </td>
                                <td style="color:${deltaColor};">
                                    ${escapeHtml(deltaText)}
                                </td>
                                <td>${Number.isFinite(weight) ? weight.toFixed(2) : '--'}</td>
                                <td>
                                    <span style="color:${scoreColor(hist)};">${Number.isFinite(hist) ? hist.toFixed(0) : '--'}</span>
                                    <span class="pl-cs-sub">N ${Number.isFinite(numericOrNaN(row && row.samples_total)) ? Number(row.samples_total) : '--'}</span>
                                </td>
                                <td style="color:${scoreColor(now)};">${Number.isFinite(now) ? now.toFixed(0) : '--'}</td>
                                <td style="color:${scoreColor(lead)};">${Number.isFinite(lead) ? lead.toFixed(0) : '--'}</td>
                                <td>
                                    ${Number.isFinite(nNow) ? nNow : '--'}
                                    <span class="pl-cs-sub">${Number.isFinite(nNowSession) ? `+${nNowSession} sess` : '--'}</span>
                                </td>
                                <td>
                                    ${Number.isFinite(nLead) ? nLead : '--'}
                                    <span class="pl-cs-sub">${Number.isFinite(nLeadSession) ? `+${nLeadSession} sess` : '--'}</span>
                                </td>
                                <td>
                                    ${escapeHtml(ageText)}
                                    <span class="pl-cs-sub">${escapeHtml(obsText)}</span>
                                </td>
                                <td><span class="pl-cs-state ${stateCls}">${escapeHtml(stateRaw)}</span></td>
                            </tr>
                        `;
                    }).join('')}
                </tbody>
            </table>
        `;
    }

    function parseReplayPointUtcMs(point) {
        if (!point || typeof point !== 'object') return NaN;
        const rawUtc = String(point.ts_ingest_utc || '').trim();
        if (rawUtc) {
            const tUtc = Date.parse(rawUtc);
            if (Number.isFinite(tUtc)) return tUtc;
        }

        const tsNyc = String(point.ts_nyc || '').trim();
        if (!tsNyc.includes(' ')) return NaN;
        const [datePart, timePart] = tsNyc.split(' ');
        if (!datePart || !timePart) return NaN;

        try {
            const nycFormatter = new Intl.DateTimeFormat('en-US', {
                timeZone: 'America/New_York',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false,
            });
            const nycShort = timePart.substring(0, 8);
            for (const offset of ['-05:00', '-04:00']) {
                const candidate = new Date(`${datePart}T${timePart}${offset}`);
                if (!Number.isFinite(candidate.getTime())) continue;
                const rendered = nycFormatter.format(candidate);
                if (rendered === nycShort) {
                    return candidate.getTime();
                }
            }
            const fallback = new Date(`${datePart}T${timePart}-05:00`);
            return fallback.getTime();
        } catch {
            return NaN;
        }
    }

    function formatSeriesAge(ageMinutes) {
        const age = numericOrNaN(ageMinutes);
        if (!Number.isFinite(age)) return '--';
        if (age < (1 / 60)) return '0s';
        if (age < 1) return `${Math.max(1, Math.round(age * 60))}s`;
        if (age < 60) return `${Math.round(age)}m`;
        const h = Math.floor(age / 60);
        const m = Math.round(age % 60);
        if (m <= 0) return `${h}h`;
        return `${h}h ${m}m`;
    }

    function computeSeriesAgeMinutes(series, pointTimesMs) {
        const out = new Array(series.length).fill(null);
        let lastUpdateTs = null;
        let lastQuantized = null;
        for (let i = 0; i < series.length; i++) {
            const v = series[i];
            const ts = pointTimesMs[i];
            const hasValue = (v !== null && v !== undefined && Number.isFinite(Number(v)));
            if (hasValue && Number.isFinite(ts)) {
                const n = Number(v);
                const quantized = Math.round(n * 10) / 10;
                const changed = !(lastQuantized !== null && Number.isFinite(lastQuantized) && quantized === lastQuantized);
                if (changed || lastUpdateTs === null) {
                    lastUpdateTs = ts;
                    lastQuantized = quantized;
                }
            }
            if (lastUpdateTs !== null && Number.isFinite(ts) && ts >= lastUpdateTs) {
                out[i] = (ts - lastUpdateTs) / 60000;
            }
        }
        return out;
    }

    function sanitizeMetarSeriesF(rawSeries) {
        const vals = rawSeries.map((v) => {
            const n = numericOrNaN(v);
            return Number.isFinite(n) ? Number(n) : null;
        });
        const nonNullIndices = () => {
            const out = [];
            for (let i = 0; i < vals.length; i++) {
                if (vals[i] !== null) out.push(i);
            }
            return out;
        };
        const nearestPrev = (idx) => {
            for (let i = idx - 1; i >= 0; i--) {
                if (vals[i] !== null) return vals[i];
            }
            return null;
        };
        const nearestNext = (idx) => {
            for (let i = idx + 1; i < vals.length; i++) {
                if (vals[i] !== null) return vals[i];
            }
            return null;
        };

        for (let i = 0; i < vals.length; i++) {
            const v = vals[i];
            if (v === null) continue;

            if (v < -90 || v > 140) {
                vals[i] = null;
                continue;
            }

            const prev = nearestPrev(i);
            const next = nearestNext(i);
            // Leading/trailing zero spikes (common ingest glitch)
            if (Math.abs(v) < 0.2) {
                const prevFar = prev !== null && prev >= 20.0 && Math.abs(prev - v) >= 18.0;
                const nextFar = next !== null && next >= 20.0 && Math.abs(next - v) >= 18.0;
                if (prevFar || nextFar) {
                    vals[i] = null;
                    continue;
                }
            }

            if (prev === null || next === null) continue;

            const neighborStable = Math.abs(prev - next) <= 6.0;
            const neighborMean = (prev + next) / 2.0;
            const zeroSpike = Math.abs(v) < 0.2 && neighborStable && neighborMean >= 20.0;
            const hardSpike = neighborStable && Math.abs(v - prev) >= 22.0 && Math.abs(v - next) >= 22.0;
            if (zeroSpike || hardSpike) {
                vals[i] = null;
            }
        }

        // Kill first-point METAR glitches that can vertically blow up replay charts.
        // Pattern: very first valid value is far from the next stable cluster.
        {
            const idx = nonNullIndices();
            if (idx.length >= 3) {
                const i0 = idx[0];
                const i1 = idx[1];
                const i2 = idx[2];
                const v0 = vals[i0];
                const v1 = vals[i1];
                const v2 = vals[i2];
                if (
                    v0 !== null && v1 !== null && v2 !== null &&
                    Math.abs(v1 - v2) <= 6.0 &&
                    Math.abs(v0 - v1) >= 18.0 &&
                    Math.abs(v0 - v2) >= 18.0
                ) {
                    vals[i0] = null;
                }
            } else if (idx.length >= 2) {
                const i0 = idx[0];
                const v0 = vals[i0];
                const tail = [];
                for (let k = 1; k < idx.length; k++) {
                    const vk = vals[idx[k]];
                    if (vk !== null) tail.push(vk);
                    if (tail.length >= 6) break;
                }
                if (v0 !== null && tail.length >= 2) {
                    const tailAvg = tail.reduce((a, b) => a + b, 0) / tail.length;
                    if (Math.abs(v0 - tailAvg) >= 20.0) {
                        vals[i0] = null;
                    }
                }
            }
        }

        // Trim leading/trailing near-zero runs when the day is otherwise warm.
        let firstIdx = vals.findIndex(v => v !== null);
        while (firstIdx >= 0 && firstIdx < vals.length && vals[firstIdx] !== null && Math.abs(vals[firstIdx]) < 0.2) {
            let nextWarm = null;
            for (let j = firstIdx + 1; j < vals.length; j++) {
                if (vals[j] !== null) {
                    nextWarm = vals[j];
                    break;
                }
            }
            if (nextWarm !== null && nextWarm >= 20.0) {
                vals[firstIdx] = null;
                firstIdx = vals.findIndex(v => v !== null);
            } else {
                break;
            }
        }

        let lastIdx = -1;
        for (let i = vals.length - 1; i >= 0; i--) {
            if (vals[i] !== null) {
                lastIdx = i;
                break;
            }
        }
        while (lastIdx >= 0 && Math.abs(vals[lastIdx]) < 0.2) {
            let prevWarm = null;
            for (let j = lastIdx - 1; j >= 0; j--) {
                if (vals[j] !== null) {
                    prevWarm = vals[j];
                    break;
                }
            }
            if (prevWarm !== null && prevWarm >= 20.0) {
                vals[lastIdx] = null;
                lastIdx = -1;
                for (let i = vals.length - 1; i >= 0; i--) {
                    if (vals[i] !== null) {
                        lastIdx = i;
                        break;
                    }
                }
            } else {
                break;
            }
        }

        const hasWarmSegment = vals.some(v => v !== null && v >= 20.0);
        if (hasWarmSegment) {
            for (let i = 0; i < vals.length; i++) {
                if (vals[i] === null) continue;
                if (Math.abs(vals[i]) < 0.2) {
                    vals[i] = null;
                    continue;
                }
                break;
            }
            for (let i = vals.length - 1; i >= 0; i--) {
                if (vals[i] === null) continue;
                if (Math.abs(vals[i]) < 0.2) {
                    vals[i] = null;
                    continue;
                }
                break;
            }
        }

        return vals;
    }

    function setReplayTrendXWindow(chart, minIdx, maxIdx) {
        if (!chart || !chart.options || !chart.options.scales || !chart.options.scales.x) return;
        const total = Array.isArray(chart.data?.labels) ? chart.data.labels.length : 0;
        if (total <= 0) return;
        const minSpan = Math.min(6, Math.max(1, total - 1));
        const fullMax = Math.max(0, total - 1);
        let min = Number(minIdx);
        let max = Number(maxIdx);
        if (!Number.isFinite(min) || !Number.isFinite(max)) return;
        if (max < min) {
            const t = min;
            min = max;
            max = t;
        }
        let span = Math.max(minSpan, max - min);
        min = Math.max(0, min);
        max = min + span;
        if (max > fullMax) {
            max = fullMax;
            min = Math.max(0, max - span);
        }
        span = Math.max(minSpan, max - min);
        chart.options.scales.x.min = Math.round(min);
        chart.options.scales.x.max = Math.round(min + span);
    }

    function resetReplayTrendZoom(chart) {
        if (!chart || !chart.options || !chart.options.scales || !chart.options.scales.x) return;
        delete chart.options.scales.x.min;
        delete chart.options.scales.x.max;
    }

    function attachReplayTrendZoomControls(canvas) {
        if (!canvas || replayTrendZoomHandlersAttached) return;
        replayTrendZoomHandlersAttached = true;

        const onWheel = (ev) => {
            const chart = replayTrendChart;
            if (!chart || !chart.scales || !chart.scales.x || !chart.chartArea) return;
            ev.preventDefault();

            const total = Array.isArray(chart.data?.labels) ? chart.data.labels.length : 0;
            if (total <= 2) return;
            const xScale = chart.scales.x;
            const curMin = Number.isFinite(Number(chart.options?.scales?.x?.min)) ? Number(chart.options.scales.x.min) : 0;
            const curMax = Number.isFinite(Number(chart.options?.scales?.x?.max)) ? Number(chart.options.scales.x.max) : (total - 1);
            const curSpan = Math.max(2, curMax - curMin);

            const zoomFactor = ev.deltaY < 0 ? 0.82 : 1.22;
            let targetSpan = curSpan * zoomFactor;
            targetSpan = Math.max(6, Math.min(total - 1, targetSpan));

            const anchorRaw = xScale.getValueForPixel(ev.offsetX);
            const anchor = Number.isFinite(Number(anchorRaw)) ? Number(anchorRaw) : (curMin + curSpan / 2);
            const leftRatio = curSpan > 0 ? (anchor - curMin) / curSpan : 0.5;

            let newMin = anchor - (targetSpan * leftRatio);
            let newMax = newMin + targetSpan;
            if (newMin < 0) {
                newMin = 0;
                newMax = targetSpan;
            }
            if (newMax > (total - 1)) {
                newMax = total - 1;
                newMin = Math.max(0, newMax - targetSpan);
            }

            setReplayTrendXWindow(chart, newMin, newMax);
            chart.update('none');
        };

        const onMouseDown = (ev) => {
            if (ev.button !== 0) return;
            const chart = replayTrendChart;
            if (!chart || !chart.scales || !chart.scales.x || !chart.chartArea) return;
            const total = Array.isArray(chart.data?.labels) ? chart.data.labels.length : 0;
            if (total <= 2) return;

            const curMin = Number.isFinite(Number(chart.options?.scales?.x?.min)) ? Number(chart.options.scales.x.min) : 0;
            const curMax = Number.isFinite(Number(chart.options?.scales?.x?.max)) ? Number(chart.options.scales.x.max) : (total - 1);
            replayTrendDragState = {
                startClientX: ev.clientX,
                startMin: curMin,
                startMax: curMax,
            };
            canvas.style.cursor = 'grabbing';
            ev.preventDefault();
        };

        const onMouseMove = (ev) => {
            if (!replayTrendDragState) return;
            const chart = replayTrendChart;
            if (!chart || !chart.chartArea) return;
            const width = Math.max(1, chart.chartArea.right - chart.chartArea.left);
            const span = replayTrendDragState.startMax - replayTrendDragState.startMin;
            if (span <= 0) return;
            const deltaPx = ev.clientX - replayTrendDragState.startClientX;
            const deltaIdx = (deltaPx / width) * span;
            setReplayTrendXWindow(
                chart,
                replayTrendDragState.startMin - deltaIdx,
                replayTrendDragState.startMax - deltaIdx,
            );
            chart.update('none');
        };

        const onMouseUp = () => {
            replayTrendDragState = null;
            canvas.style.cursor = 'crosshair';
        };

        const onDblClick = (ev) => {
            const chart = replayTrendChart;
            if (!chart) return;
            ev.preventDefault();
            resetReplayTrendZoom(chart);
            chart.update('none');
        };

        canvas.style.cursor = 'crosshair';
        canvas.addEventListener('wheel', onWheel, { passive: false });
        canvas.addEventListener('mousedown', onMouseDown);
        canvas.addEventListener('dblclick', onDblClick);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
        canvas.addEventListener('mouseleave', onMouseUp);
    }

    function renderReplayTrend(trendPayload, stationId = currentStationId()) {
        const panel = document.getElementById('replay-trend-panel');
        const metaEl = document.getElementById('rt-meta');
        const top3El = document.getElementById('rt-top3');
        const canvas = document.getElementById('replay-trend-chart');
        if (!panel || !metaEl || !top3El || !canvas || typeof Chart === 'undefined') return;

        const payload = trendPayload && typeof trendPayload === 'object' ? trendPayload : {};
        const points = Array.isArray(payload.points) ? payload.points : [];
        const resolution = String(payload.resolution || 'event').toLowerCase();
        const latest = payload.latest && typeof payload.latest === 'object'
            ? payload.latest
            : (points.length ? points[points.length - 1] : null);

        if (!points.length) {
            panel.classList.remove('visible');
            if (replayTrendChart) {
                replayTrendChart.destroy();
                replayTrendChart = null;
            }
            return;
        }

        const asNumOrNull = (v) => {
            const n = numericOrNaN(v);
            return Number.isFinite(n) ? n : null;
        };
        const asTempOrNull = (v) => {
            const temp = convertTempFromF(v, stationId);
            return temp == null || !Number.isFinite(Number(temp)) ? null : Number(temp);
        };

        const labels = points.map((p) => {
            if (resolution === 'hourly' && p && p.bucket_local_hour) {
                const raw = String(p.bucket_local_hour);
                if (raw.length >= 16) return raw.substring(11, 16);
            }
            if (resolution === '5min' && p && p.bucket_local_5m) {
                const raw = String(p.bucket_local_5m);
                if (raw.length >= 16) return raw.substring(11, 16);
            }
            const ts = String(p && p.ts_nyc || '');
            if (!ts) return '--';
            const tz = localTimeFromTsNyc(ts);
            return tz.local || '--';
        });
        const pointTimesMs = points.map((p) => parseReplayPointUtcMs(p));

        const pmBracketMidpointTemp = (point, rank) => {
            const prob = asNumOrNull(point && point[`pm_top${rank}_prob_pct`]);
            if (prob == null) return null;
            const midFromBackend = asNumOrNull(point && point[`pm_top${rank}_midpoint_f`]);
            const rawLabel = point ? point[`pm_top${rank}_label`] : null;
            const labelText = String(rawLabel || '').trim();
            if (!labelText || labelText === '-' || labelText === '--') return null;
            const midF = midFromBackend != null ? midFromBackend : marketBracketMidpointF(rawLabel, stationId);
            if (midF != null && (midF < -90 || midF > 140)) return null;
            return asTempOrNull(midF);
        };

        const dsTop1 = points.map((p) => pmBracketMidpointTemp(p, 1));
        const dsTop2 = points.map((p) => pmBracketMidpointTemp(p, 2));
        const dsTop3 = points.map((p) => pmBracketMidpointTemp(p, 3));
        const metarRawF = points.map((p) => asNumOrNull(p && p.metar_temp_f));
        const metarCleanF = sanitizeMetarSeriesF(metarRawF);
        const dsMetar = metarCleanF.map((v) => asTempOrNull(v));
        const dsPwsConsensus = points.map((p) => asTempOrNull(p && p.pws_consensus_f));
        const dsPwsLeader = points.map((p) => asTempOrNull(p && p.pws_top_weight_temp_f));
        const dsHelios = points.map((p) => asTempOrNull(p && p.helios_prediction_f));
        const ageMetar = computeSeriesAgeMinutes(dsMetar, pointTimesMs);
        const agePwsConsensus = computeSeriesAgeMinutes(dsPwsConsensus, pointTimesMs);
        const agePwsLeader = computeSeriesAgeMinutes(dsPwsLeader, pointTimesMs);
        const ageHelios = computeSeriesAgeMinutes(dsHelios, pointTimesMs);
        const hasPmData = dsTop1.some(v => v !== null) || dsTop2.some(v => v !== null) || dsTop3.some(v => v !== null);

        panel.classList.add('visible');
        const unit = tempUnitSymbol(stationId).trim();
        const total = Number(payload.total_points || points.length);
        const rawTotal = Number(payload.total_points_raw || total);
        const latestTs = String(latest && latest.ts_nyc || '--');
        let resLabel = 'event';
        if (resolution === 'hourly') {
            resLabel = `hourly (${String(payload.bin_timezone || '--')})`;
        } else if (resolution === '5min') {
            resLabel = `5min (${String(payload.bin_timezone || '--')})`;
        }
        metaEl.textContent = `${points.length}/${total} points | raw ${rawTotal} | ${resLabel} | temp unit ${unit} | latest ${latestTs} | zoom wheel/pan drag/dblclick reset`;

        const topLabel = (idx) => {
            const rank = idx + 1;
            const rawLbl = String(latest && latest[`pm_top${rank}_label`] || '--');
            const lbl = formatBucketLabelForStation(rawLbl, stationId);
            const prob = asNumOrNull(latest && latest[`pm_top${rank}_prob_pct`]);
            const probStr = prob == null ? '--' : `${prob.toFixed(1)}%`;
            const midpointRaw = asNumOrNull(latest && latest[`pm_top${rank}_midpoint_f`]);
            const midpointF = midpointRaw != null ? midpointRaw : marketBracketMidpointF(rawLbl, stationId);
            const midpointText = midpointF == null ? '--' : formatTempFromF(midpointF, 1, stationId);
            return `Top${rank} ${midpointText} (${probStr}) ${lbl}`;
        };
        if (hasPmData) {
            top3El.innerHTML = [
                `<span class="rt-pill">${escapeHtml(topLabel(0))}</span>`,
                `<span class="rt-pill">${escapeHtml(topLabel(1))}</span>`,
                `<span class="rt-pill">${escapeHtml(topLabel(2))}</span>`,
            ].join('');
        } else {
            top3El.innerHTML = '<span class="rt-pill">Polymarket: no valid bracket data in this replay window</span>';
        }

        const datasets = [
            {
                label: 'NOAA METAR',
                data: dsMetar,
                yAxisID: 'yTemp',
                borderColor: '#10B981',
                backgroundColor: 'rgba(16,185,129,0.16)',
                borderWidth: 2.0,
                pointRadius: 0,
                tension: 0.22,
                spanGaps: true,
                ageMinutes: ageMetar,
            },
            {
                label: 'PWS Consensus',
                data: dsPwsConsensus,
                yAxisID: 'yTemp',
                borderColor: '#22D3EE',
                backgroundColor: 'rgba(34,211,238,0.16)',
                borderWidth: 2.0,
                pointRadius: 0,
                tension: 0.22,
                spanGaps: true,
                ageMinutes: agePwsConsensus,
            },
            {
                label: 'PWS Top Weight',
                data: dsPwsLeader,
                yAxisID: 'yTemp',
                borderColor: '#F97316',
                backgroundColor: 'rgba(249,115,22,0.16)',
                borderWidth: 1.8,
                pointRadius: 0,
                tension: 0.22,
                spanGaps: true,
                ageMinutes: agePwsLeader,
            },
            {
                label: 'Helios Pred',
                data: dsHelios,
                yAxisID: 'yTemp',
                borderColor: '#3B82F6',
                backgroundColor: 'rgba(59,130,246,0.16)',
                borderWidth: 2.2,
                pointRadius: 0,
                tension: 0.22,
                spanGaps: true,
                ageMinutes: ageHelios,
            },
        ];
        const chartData = { labels, datasets };
        if (!replayTrendChart) {
            const ctx = canvas.getContext('2d');
            replayTrendChart = new Chart(ctx, {
                type: 'line',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    normalized: true,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: '#94a3b8',
                                boxWidth: 10,
                                boxHeight: 10,
                                font: { size: 10 },
                            },
                        },
                        tooltip: {
                            callbacks: {
                                title: (items) => {
                                    const i = items && items[0] ? items[0].dataIndex : -1;
                                    if (i < 0 || i >= points.length) return '--';
                                    return String(points[i].ts_nyc || labels[i] || '--');
                                },
                                label: (ctx) => {
                                    const dsLabel = String(ctx?.dataset?.label || 'Value');
                                    const rawY = Number(ctx?.raw);
                                    const hasY = Number.isFinite(rawY);
                                    const yVal = hasY ? rawY : Number(ctx?.parsed?.y);
                                    const valueStr = Number.isFinite(yVal) && hasY ? `${yVal.toFixed(1)} ${unit}` : '--';
                                    const i = Number(ctx?.dataIndex);
                                    const ageValues = Array.isArray(ctx?.dataset?.ageMinutes) ? ctx.dataset.ageMinutes : [];
                                    const age = (i >= 0 && i < ageValues.length) ? ageValues[i] : null;
                                    const ageStr = formatSeriesAge(age);
                                    const pmRank = Number(ctx?.dataset?.pmRank);
                                    if (Number.isFinite(pmRank) && pmRank >= 1 && pmRank <= 3) {
                                        const point = (i >= 0 && i < points.length) ? points[i] : null;
                                        const rawLabel = String(point && point[`pm_top${pmRank}_label`] || '--');
                                        const bucketLabel = formatBucketLabelForStation(rawLabel, stationId);
                                        const prob = asNumOrNull(point && point[`pm_top${pmRank}_prob_pct`]);
                                        const probStr = prob == null ? '--' : `${prob.toFixed(1)}%`;
                                        return `${dsLabel}: ${valueStr} (${probStr}) [${bucketLabel}] | age ${ageStr}`;
                                    }
                                    return `${dsLabel}: ${valueStr} | age ${ageStr}`;
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: '#64748b',
                                maxTicksLimit: 12,
                            },
                            grid: {
                                color: 'rgba(255,255,255,0.05)',
                            },
                        },
                        yTemp: {
                            type: 'linear',
                            position: 'left',
                            ticks: {
                                color: '#94a3b8',
                            },
                            title: {
                                display: true,
                                text: `Temp (${unit})`,
                                color: '#94a3b8',
                            },
                            grid: {
                                color: 'rgba(255,255,255,0.06)',
                            },
                        },
                    },
                },
            });
            attachReplayTrendZoomControls(canvas);
        } else {
            const xOpts = replayTrendChart.options && replayTrendChart.options.scales
                ? replayTrendChart.options.scales.x
                : null;
            if (xOpts) {
                const lastIdx = Math.max(0, labels.length - 1);
                if (Number.isFinite(Number(xOpts.min))) {
                    xOpts.min = Math.max(0, Math.min(lastIdx, Number(xOpts.min)));
                }
                if (Number.isFinite(Number(xOpts.max))) {
                    xOpts.max = Math.max(0, Math.min(lastIdx, Number(xOpts.max)));
                }
                if (Number.isFinite(Number(xOpts.min)) && Number.isFinite(Number(xOpts.max)) && Number(xOpts.max) <= Number(xOpts.min)) {
                    const targetMax = Math.min(lastIdx, Number(xOpts.min) + 6);
                    xOpts.max = targetMax;
                }
            }
            replayTrendChart.data = chartData;
            if (replayTrendChart.options && replayTrendChart.options.scales && replayTrendChart.options.scales.yTemp) {
                replayTrendChart.options.scales.yTemp.title.text = `Temp (${unit})`;
            }
            replayTrendChart.update('none');
        }
    }

    function renderPwsLearning(payload, categories = null) {
        const panel = document.getElementById('pws-learning-panel');
        const metaEl = document.getElementById('pl-meta');
        const guideEl = document.getElementById('pl-guide');
        const rankingEl = document.getElementById('pl-ranking');
        const stripEl = document.getElementById('pl-strip');
        const stripSummaryEl = document.getElementById('pl-strip-summary');
        const eventsEl = document.getElementById('pl-events');
        const consensusSummaryEl = document.getElementById('pl-consensus-summary');
        const consensusTableEl = document.getElementById('pl-consensus-table');

        if (!panel || !metaEl || !guideEl || !rankingEl || !stripEl || !stripSummaryEl || !eventsEl || !consensusSummaryEl || !consensusTableEl) return;

        if (!payload || payload.error) {
            panel.classList.remove('visible');
            renderReplayTrend(null, currentStationId());
            return;
        }

        const current = payload.current || null;
        const stationId = current && current.market_station_id
            ? String(current.market_station_id).toUpperCase()
            : currentStationId();
        const top = current && Array.isArray(current.top) ? current.top : [];
        const totalPws = Number(payload.total_pws_events || 0);
        const rankedPws = Number(payload.ranked_pws_events || 0);
        const weightedSupport = Number(current && current.weighted_support);
        const status = String((current && current.status) || 'WARMUP').toUpperCase();
        const warmupReason = String((current && current.warmup_reason) || '').trim();
        const marketStation = String((current && current.market_station_id) || '--');

        if (!current) {
            panel.classList.remove('visible');
            renderReplayTrend(payload.trend || null, currentStationId());
            return;
        }

        const categoryWorld = categories && categories.world && categories.world.latest
            ? categories.world.latest
            : null;
        const worldTemp = numericOrNaN(categoryWorld && categoryWorld.data ? categoryWorld.data.temp_f : NaN);
        const metarTempFromLearning = numericOrNaN(current.metar_temp_f);
        const metarTemp = Number.isFinite(metarTempFromLearning) ? metarTempFromLearning : worldTemp;
        const pwsMedian = numericOrNaN(current.median_f);
        const deltaFromLearning = numericOrNaN(current.pws_vs_metar_f);
        const deltaVsMetar = Number.isFinite(deltaFromLearning)
            ? deltaFromLearning
            : (Number.isFinite(pwsMedian) && Number.isFinite(metarTemp) ? (pwsMedian - metarTemp) : NaN);
        const metarTime = String(current.metar_ts_nyc || (categoryWorld && categoryWorld.ts_nyc) || '--');
        const metarSource = String(current.metar_source || ((categoryWorld && categoryWorld.data && categoryWorld.data.src) || 'METAR'));
        const metarTempText = formatTempFromF(metarTemp, 1, stationId);
        const pwsMedianText = formatTempFromF(pwsMedian, 1, stationId);
        const deltaText = formatSignedDeltaFromF(deltaVsMetar, 1, stationId);
        const pwsTickNyc = String(current.ts_nyc || '--');
        const pwsTick = pwsTickNyc !== '--'
            ? localTimeFromTsNyc(pwsTickNyc)
            : { local: '--:--', es: '--:--' };
        const pwsTickLabel = `${pwsTick.local} ${localTzLabel} | ${pwsTick.es} ES`;

        renderReplayTrend(payload.trend || null, stationId);

        panel.classList.add('visible');
        metaEl.textContent = `${totalPws} pws ev | ranked ${rankedPws} | market ${marketStation} | pws tick ${pwsTickLabel} | status ${status} | w-support ${Number.isFinite(weightedSupport) ? weightedSupport.toFixed(2) : '--'}`;
        guideEl.innerHTML = [
            '<span class="pl-guide-pill"><strong>w</strong> peso dinamico (no temperatura): now + ajuste lead</span>',
            '<span class="pl-guide-pill"><strong>now</strong> score 0-100 vs METAR actual</span>',
            '<span class="pl-guide-pill"><strong>lead</strong> score 0-100 con adelanto 35-85 min (EMA)</span>',
            '<span class="pl-guide-pill"><strong>N now/N lead</strong> historico acumulado (multidia), no solo esta hora</span>',
            `<span class="pl-guide-pill"><strong>PWS tick</strong> ${pwsTickLabel} (${pwsTickNyc} NYC)</span>`,
            `<span class="pl-guide-pill"><strong>METAR</strong> ${metarTempText} (${metarSource}, ${metarTime})</span>`,
            `<span class="pl-guide-pill"><strong>PWS median</strong> ${pwsMedianText} | <strong>delta</strong> ${deltaText}</span>`,
        ].join('');

        renderPwsConsensusSnapshot(payload.consensus_snapshot || null, {
            summaryEl: consensusSummaryEl,
            tableEl: consensusTableEl,
            stationId,
            metarTempF: metarTemp,
            leaderStationId: top.length > 0 ? String(top[0].station_id || '').toUpperCase() : '',
            pwsTickLabel,
            pwsTickNyc,
        });

        const isReady = status === 'READY' && top.length > 0;
        if (!isReady) {
            const minNow = Number.isFinite(numericOrNaN(current.rank_min_now_samples)) ? Number(current.rank_min_now_samples) : 2;
            const minLead = Number.isFinite(numericOrNaN(current.rank_min_lead_samples)) ? Number(current.rank_min_lead_samples) : 1;
            const fallbackReason = `Warm-up: ranking appears when station reaches now>=${minNow} and lead>=${minLead}.`;
            rankingEl.innerHTML = `<div class="pl-empty">${warmupReason || fallbackReason}</div>`;
            stripEl.innerHTML = '<div class="pl-empty">No leader timeline yet (ranking still warming up)</div>';
            stripSummaryEl.textContent = 'No leader summary yet';
            eventsEl.innerHTML = '<div class="pl-empty">No leader switches yet</div>';
            return;
        }

        rankingEl.innerHTML = top.map((row, idx) => {
            const station = row.station_id || '--';
            const w = numericOrNaN(row.weight);
            const now = numericOrNaN(row.now_score);
            const lead = numericOrNaN(row.lead_score);
            const nNow = numericOrNaN(row.now_samples);
            const nLead = numericOrNaN(row.lead_samples);
            const errNowC = numericOrNaN(row.now_ema_abs_error_c);
            const errLeadC = numericOrNaN(row.lead_ema_abs_error_c);
            const nowColor = scoreColor(now);
            const leadColor = scoreColor(lead);
            return `
                <div class="pl-rank-item">
                    <div class="pl-rank-row">
                        <span class="pl-rank-pos">#${idx + 1}</span>
                        <span class="pl-rank-station">${station}</span>
                        <span class="pl-pill">w ${Number.isFinite(w) ? w.toFixed(2) : '--'}</span>
                        <span class="pl-pill" style="color:${nowColor};">now ${Number.isFinite(now) ? now.toFixed(0) : '--'}</span>
                        <span class="pl-pill" style="color:${leadColor};">lead ${Number.isFinite(lead) ? lead.toFixed(0) : '--'}</span>
                    </div>
                    <div class="pl-rank-meta">N now(H) ${Number.isFinite(nNow) ? nNow : '--'} | N lead(H) ${Number.isFinite(nLead) ? nLead : '--'} | err now ${Number.isFinite(errNowC) ? errNowC.toFixed(2) + 'C' : '--'} | err lead ${Number.isFinite(errLeadC) ? errLeadC.toFixed(2) + 'C' : '--'}</div>
                </div>
            `;
        }).join('');

        const timeline = Array.isArray(payload.timeline) ? payload.timeline : [];
        if (timeline.length === 0) {
            stripEl.innerHTML = '<div class="pl-empty">No timeline</div>';
            stripSummaryEl.textContent = 'No leader summary yet';
        } else {
            const weights = timeline
                .map(p => numericOrNaN(p.leader_weight))
                .filter(v => Number.isFinite(v));
            const minW = weights.length ? Math.min(...weights) : 0.0;
            const maxW = weights.length ? Math.max(...weights) : 1.0;
            const span = Math.max(0.001, maxW - minW);

            stripEl.innerHTML = timeline.map((p) => {
                const w = numericOrNaN(p.leader_weight);
                const now = numericOrNaN(p.leader_now_score);
                const lead = numericOrNaN(p.leader_lead_score);
                const pointDelta = numericOrNaN(p.pws_vs_metar_f);
                const h = Number.isFinite(w)
                    ? Math.max(12, Math.round(((w - minW) / span) * 84))
                    : 12;
                const nowColor = scoreColor(now);
                const leadColor = scoreColor(lead);
                const title = `${p.ts_nyc || '--'} | ${p.leader_station_id || '--'} | w=${Number.isFinite(w) ? w.toFixed(2) : '--'} | now=${Number.isFinite(now) ? now.toFixed(0) : '--'} | lead=${Number.isFinite(lead) ? lead.toFixed(0) : '--'} | pws-metar=${formatSignedDeltaFromF(pointDelta, 1, stationId)}`;
                return `<div class="pl-leader-bar" style="height:${h}px; background:linear-gradient(180deg, ${leadColor}AA 0%, ${nowColor}55 100%);" title="${title}"></div>`;
            }).join('');

            const last = timeline[timeline.length - 1] || {};
            const lastW = numericOrNaN(last.leader_weight);
            const lastNow = numericOrNaN(last.leader_now_score);
            const lastLead = numericOrNaN(last.leader_lead_score);
            const lastDelta = numericOrNaN(last.pws_vs_metar_f);
            stripSummaryEl.textContent = `Latest leader ${last.leader_station_id || '--'} | w ${Number.isFinite(lastW) ? lastW.toFixed(2) : '--'} | now ${Number.isFinite(lastNow) ? lastNow.toFixed(0) : '--'} | lead ${Number.isFinite(lastLead) ? lastLead.toFixed(0) : '--'} | pws-metar ${formatSignedDeltaFromF(lastDelta, 1, stationId)}`;
        }

        const leaderChanges = Array.isArray(payload.leader_changes) ? payload.leader_changes : [];
        if (leaderChanges.length === 0) {
            eventsEl.innerHTML = '<div class="pl-empty">No leader switches</div>';
        } else {
            const recent = leaderChanges.slice(-8).reverse();
            eventsEl.innerHTML = recent.map((p) => {
                const w = numericOrNaN(p.leader_weight);
                const now = numericOrNaN(p.leader_now_score);
                const lead = numericOrNaN(p.leader_lead_score);
                return `
                    <div class="pl-leader-event">
                        <span>${p.ts_nyc || '--'}</span>
                        <span><strong>${p.leader_station_id || '--'}</strong> | w ${Number.isFinite(w) ? w.toFixed(2) : '--'} | now ${Number.isFinite(now) ? now.toFixed(0) : '--'} | lead ${Number.isFinite(lead) ? lead.toFixed(0) : '--'}</span>
                    </div>
                `;
            }).join('');
        }
    }

    function renderMarketPanel(data, timestamp, emptyReason = 'No market data for this replay segment', stationIdOverride = null) {
        const panel = document.getElementById('market-replay-panel');
        const grid = document.getElementById('mr-grid');
        const timeEl = document.getElementById('mr-time');
        const stationId = String(stationIdOverride || currentStationId()).toUpperCase();

        if (!panel || !grid || !timeEl) return;
        if (!data || typeof data !== 'object') {
            panel.classList.add('visible');
            timeEl.textContent = '--';
            grid.innerHTML = `<div class="mr-empty">${emptyReason}</div>`;
            return;
        }

        // Parse brackets (exclude __meta__)
        const brackets = Object.entries(data)
            .filter(([k]) => k !== '__meta__')
            .map(([name, b]) => ({
                name: formatBucketLabelForStation(name, stationId),
                mid: b.mid || 0,
                best_bid: b.best_bid || 0,
                best_ask: b.best_ask || 0,
                spread: b.spread || 0,
                bid_depth: b.bid_depth || 0,
                ask_depth: b.ask_depth || 0,
            }))
            .sort((a, b) => b.mid - a.mid);

        if (brackets.length === 0) {
            panel.classList.add('visible');
            timeEl.textContent = timestamp || '--';
            grid.innerHTML = '<div class="mr-empty">No bracket books in this market snapshot</div>';
            return;
        }

        panel.classList.add('visible');
        timeEl.textContent = timestamp || '--';

        grid.innerHTML = brackets.map((b, idx) => {
            const totalDepth = b.bid_depth + b.ask_depth;
            const bidPct = totalDepth > 0 ? (b.bid_depth / totalDepth * 100).toFixed(0) : 50;
            const askPct = totalDepth > 0 ? (b.ask_depth / totalDepth * 100).toFixed(0) : 50;
            const isLeading = idx === 0;

            return `
                <div class="mr-bracket${isLeading ? ' leading' : ''}">
                    <div class="mr-bracket-name">${b.name}</div>
                    <div class="mr-bracket-price">${(b.mid * 100).toFixed(1)}%</div>
                    <div class="mr-bracket-book">
                        <span class="mr-bid">${(b.best_bid * 100).toFixed(1)}c</span>
                        <span class="mr-spread">${(b.spread * 100).toFixed(1)}c</span>
                        <span class="mr-ask">${(b.best_ask * 100).toFixed(1)}c</span>
                    </div>
                    <div class="mr-depth-bar">
                        <div class="mr-depth-bid" style="width:${bidPct}%"></div>
                        <div class="mr-depth-ask" style="width:${askPct}%"></div>
                    </div>
                </div>`;
        }).join('');
    }

    function updatePlayButton() {
        const icon = document.getElementById('play-icon');
        if (isPlaying) {
            icon.setAttribute('data-lucide', 'pause');
        } else {
            icon.setAttribute('data-lucide', 'play');
        }
        lucide.createIcons();
    }

    async function togglePlayPause() {
        if (!sessionId) return;

        const action = isPlaying ? 'pause' : 'play';
        try {
            const resp = await fetch(`/api/v4/replay/session/${sessionId}/${action}?speed=${currentSpeed}`, {
                method: 'POST'
            });
            const data = await resp.json();
            if (data.error) {
                alert(data.error);
                return;
            }
            if (data.state) {
                isPlaying = data.state === 'playing';
            } else {
                isPlaying = !isPlaying;
            }
            updatePlayButton();
            await updateState(true);
        } catch (e) {
            console.error('Play/pause error:', e);
        }
    }

    async function stopSession() {
        if (!sessionId) return;

        try {
            const resp = await fetch(`/api/v4/replay/session/${sessionId}/stop`, {
                method: 'POST'
            });
            const data = await resp.json();
            if (data.error) {
                alert(data.error);
                return;
            }
            isPlaying = data.state === 'playing';
            updatePlayButton();
            await updateState(true);
        } catch (e) {
            console.error('Stop error:', e);
        }
    }

    function adjustPollInterval() {
        if (pollInterval) clearInterval(pollInterval);
        const interval = pollIntervalMsForSpeed(currentSpeed);
        pollInterval = setInterval(updateState, interval);
    }

    async function setSpeed(speed) {
        currentSpeed = speed;

        // Update UI
        document.querySelectorAll('.speed-btn').forEach(btn => {
            btn.classList.toggle('active', parseInt(btn.dataset.speed) === speed);
        });

        // Adjust poll frequency for new speed
        if (sessionId) adjustPollInterval();

        // Update speed on server (playing or paused)
        if (sessionId) {
            try {
                const resp = await fetch(`/api/v4/replay/session/${sessionId}/speed?speed=${speed}`, {
                    method: 'POST'
                });
                const data = await resp.json();
                if (data.error) {
                    alert(data.error);
                    return;
                }
                await updateState(true);
            } catch (e) {
                console.error('Speed change error:', e);
            }
        }
    }

    async function seek(percent) {
        if (!sessionId) return;
        const clamped = Math.max(0, Math.min(100, Number(percent) || 0));
        queuedSeekPercent = clamped;
        if (seekInFlight) return;

        seekInFlight = true;

        try {
            while (queuedSeekPercent !== null) {
                const target = queuedSeekPercent;
                queuedSeekPercent = null;
                const resp = await fetch(`/api/v4/replay/session/${sessionId}/seek?percent=${target}`, {
                    method: 'POST'
                });
                const data = await resp.json();
                if (data.error) {
                    alert(data.error);
                    return;
                }
            }
            await updateState(true);
        } catch (e) {
            console.error('Seek error:', e);
        } finally {
            seekInFlight = false;
        }
    }

    async function jump(type) {
        if (!sessionId) return;

        try {
            const resp = await fetch(`/api/v4/replay/session/${sessionId}/jump/${type}`, {
                method: 'POST'
            });
            const data = await resp.json();
            if (data.error) {
                alert(data.error);
                return;
            }
            await updateState(true);
        } catch (e) {
            console.error('Jump error:', e);
        }
    }

    // Cleanup
    window.addEventListener('beforeunload', () => {
        if (pollInterval) clearInterval(pollInterval);
    });

    document.addEventListener('DOMContentLoaded', () => {
        window.addEventListener('helios:stationchange', async (event) => {
            if (!isReplayStationFilterVisible()) return;
            const nextStation = event?.detail?.stationId;
            const sel = document.getElementById('station-select');
            if (!nextStation || !sel || sel.value === nextStation) return;
            if (!Array.from(sel.options).some(o => o.value === nextStation)) return;
            sel.value = nextStation;
            updateReplayFormatters();
            await loadAvailableDates();
            updateLoadButton();
        });
        init();
    });
})();
</script>
{% endblock %}

